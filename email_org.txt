# EMAIL ORGANIZATION APPLICATION
# This file contains all modules and configurations for the Email Organization Application.
# The setup.py script will parse this file to extract individual modules and place them in the appropriate directories.

# REQUIREMENTS.TXT
Flask==2.0.1
Flask-RESTful==0.3.9
Flask-SQLAlchemy==2.5.1
Flask-Login==0.5.0
SQLAlchemy==1.4.23
python-dotenv==0.19.0
beautifulsoup4==4.10.0
lxml==4.6.3
email-validator==1.1.3
exchangelib==4.6.2
google-api-python-client==2.19.1
google-auth-httplib2==0.1.0
google-auth-oauthlib==0.4.6
nltk==3.6.3
python-magic==0.4.24
Pillow==8.3.2
cryptography==3.4.8
pydub==0.25.1
SpeechRecognition==3.8.1
openai==0.27.0
langchain==0.0.267
pymongo==4.3.3
elasticsearch==8.5.0
pytest==7.0.0
gunicorn==20.1.0

# CONFIG.JSON
{
    "app": {
        "name": "Email Organization Application",
        "debug": true,
        "secret_key": "change_this_to_a_secure_random_string",
        "log_level": "INFO",
        "host": "0.0.0.0",
        "port": 5000
    },
    "database": {
        "type": "sqlite",
        "connection_string": "sqlite:///data/email_org.db",
        "mongodb": {
            "host": "localhost",
            "port": 27017,
            "database": "email_org"
        },
        "elasticsearch": {
            "host": "localhost",
            "port": 9200
        }
    },
    "email": {
        "batch_size": 100,
        "polling_interval": 300,
        "max_attachment_size": 25000000
    },
    "storage": {
        "attachments_dir": "data/attachments",
        "bodies_dir": "data/bodies",
        "html_objects_dir": "data/html_objects",
        "emails_dir": "data/emails",
        "threads_dir": "data/threads",
        "disclaimers_dir": "data/disclaimers"
    },
    "ai": {
        "openai_api_key": "",
        "model": "gpt-4",
        "temperature": 0.7,
        "max_tokens": 1000
    },
    "search": {
        "min_keyword_length": 3,
        "stopwords_file": "config/stopwords.txt",
        "max_results": 100
    },
    "rules": {
        "max_rules_per_domain": 50,
        "max_rules_per_contact": 20
    }
}

# DATABASE_MODELS.PY
"""
Database models for the Email Organization Application.
These models define the structure of the database tables.
"""

from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, ForeignKey, Table, Float
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
import datetime
import json
import uuid

Base = declarative_base()

# Association tables for many-to-many relationships
email_to_category = Table(
    'email_to_category', 
    Base.metadata,
    Column('email_id', String(36), ForeignKey('emails.id')),
    Column('category_id', String(36), ForeignKey('categories.id'))
)

thread_to_category = Table(
    'thread_to_category', 
    Base.metadata,
    Column('thread_id', String(36), ForeignKey('threads.id')),
    Column('category_id', String(36), ForeignKey('categories.id'))
)

contact_to_category = Table(
    'contact_to_category', 
    Base.metadata,
    Column('contact_id', String(36), ForeignKey('contacts.id')),
    Column('category_id', String(36), ForeignKey('categories.id'))
)

domain_to_category = Table(
    'domain_to_category', 
    Base.metadata,
    Column('domain_id', String(36), ForeignKey('domains.id')),
    Column('category_id', String(36), ForeignKey('categories.id'))
)

email_to_rule = Table(
    'email_to_rule', 
    Base.metadata,
    Column('email_id', String(36), ForeignKey('emails.id')),
    Column('rule_id', String(36), ForeignKey('rules.id'))
)

thread_to_rule = Table(
    'thread_to_rule', 
    Base.metadata,
    Column('thread_id', String(36), ForeignKey('threads.id')),
    Column('rule_id', String(36), ForeignKey('rules.id'))
)

domain_to_rule = Table(
    'domain_to_rule', 
    Base.metadata,
    Column('domain_id', String(36), ForeignKey('domains.id')),
    Column('rule_id', String(36), ForeignKey('rules.id'))
)

email_to_attachment = Table(
    'email_to_attachment', 
    Base.metadata,
    Column('email_id', String(36), ForeignKey('emails.id')),
    Column('attachment_id', String(36), ForeignKey('attachments.id'))
)

email_read_by = Table(
    'email_read_by', 
    Base.metadata,
    Column('email_id', String(36), ForeignKey('emails.id')),
    Column('user_id', String(36), ForeignKey('users.id')),
    Column('read_date', DateTime, default=datetime.datetime.utcnow)
)

html_page_to_html_object = Table(
    'html_page_to_html_object', 
    Base.metadata,
    Column('html_page_id', String(36), ForeignKey('html_pages.id')),
    Column('html_object_id', String(36), ForeignKey('html_objects.id'))
)

html_page_to_disclaimer = Table(
    'html_page_to_disclaimer', 
    Base.metadata,
    Column('html_page_id', String(36), ForeignKey('html_pages.id')),
    Column('disclaimer_id', String(36), ForeignKey('disclaimers.id'))
)

body_to_disclaimer = Table(
    'body_to_disclaimer', 
    Base.metadata,
    Column('body_id', String(36), ForeignKey('bodies.id')),
    Column('disclaimer_id', String(36), ForeignKey('disclaimers.id'))
)

email_to_disclaimer = Table(
    'email_to_disclaimer', 
    Base.metadata,
    Column('email_id', String(36), ForeignKey('emails.id')),
    Column('disclaimer_id', String(36), ForeignKey('disclaimers.id'))
)

class User(Base):
    """User model for authentication and authorization."""
    __tablename__ = 'users'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    username = Column(String(100), unique=True, nullable=False)
    email = Column(String(255), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    first_name = Column(String(100))
    last_name = Column(String(100))
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    # Relationships
    email_accounts = relationship("EmailAccount", back_populates="user")
    
    def __repr__(self):
        return f"<User {self.username}>"

class EmailAccount(Base):
    """Email account model for storing user email account credentials."""
    __tablename__ = 'email_accounts'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String(36), ForeignKey('users.id'), nullable=False)
    account_type = Column(String(50), nullable=False)  # 'exchange', 'gmail', etc.
    email_address = Column(String(255), nullable=False)
    encrypted_credentials = Column(Text, nullable=False)
    is_active = Column(Boolean, default=True)
    last_sync = Column(DateTime)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    # Relationships
    user = relationship("User", back_populates="email_accounts")
    
    def __repr__(self):
        return f"<EmailAccount {self.email_address}>"

class Contact(Base):
    """Contact model for storing email contacts."""
    __tablename__ = 'contacts'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    email = Column(String(255), nullable=False, unique=True)
    first_name = Column(String(100))
    last_name = Column(String(100))
    priority = Column(Integer, default=0)
    retention_policy = Column(String(50), default="standard")
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    # Relationships
    categories = relationship("Category", secondary=contact_to_category, back_populates="contacts")
    
    def __repr__(self):
        return f"<Contact {self.email}>"

class Domain(Base):
    """Domain model for storing email domains."""
    __tablename__ = 'domains'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    domain_name = Column(String(255), nullable=False, unique=True)
    priority = Column(Integer, default=0)
    retention_policy = Column(String(50), default="standard")
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    # Relationships
    categories = relationship("Category", secondary=domain_to_category, back_populates="domains")
    rules = relationship("Rule", secondary=domain_to_rule, back_populates="domains")
    
    def __repr__(self):
        return f"<Domain {self.domain_name}>"

class Email(Base):
    """Email model for storing processed emails."""
    __tablename__ = 'emails'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    original_id = Column(String(255))  # Original email ID from the email provider
    from_address = Column(String(255), nullable=False)
    to_addresses = Column(Text, nullable=False)  # JSON list
    cc_addresses = Column(Text)  # JSON list
    bcc_addresses = Column(Text)  # JSON list
    subject = Column(Text)
    format = Column(String(10), default="text")  # 'text' or 'html'
    date_sent = Column(DateTime)
    body_id = Column(String(36), ForeignKey('bodies.id'))
    html_id = Column(String(36), ForeignKey('html_pages.id'))
    thread_id = Column(String(36), ForeignKey('threads.id'))
    priority = Column(Integer, default=0)
    spam_score = Column(Float, default=0.0)
    confidential = Column(Boolean, default=False)
    retention_policy = Column(String(50), default="standard")
    forwarded_emails = Column(Text)  # JSON list of email IDs
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    # Relationships
    body = relationship("Body", back_populates="emails")
    html_page = relationship("HtmlPage", back_populates="emails")
    thread = relationship("Thread", back_populates="emails")
    categories = relationship("Category", secondary=email_to_category, back_populates="emails")
    rules = relationship("Rule", secondary=email_to_rule, back_populates="emails")
    attachments = relationship("Attachment", secondary=email_to_attachment, back_populates="emails")
    disclaimers = relationship("Disclaimer", secondary=email_to_disclaimer, back_populates="emails")
    read_by = relationship("User", secondary=email_read_by)
    
    def get_to_addresses(self):
        return json.loads(self.to_addresses)
    
    def set_to_addresses(self, addresses):
        self.to_addresses = json.dumps(addresses)
    
    def get_cc_addresses(self):
        return json.loads(self.cc_addresses) if self.cc_addresses else []
    
    def set_cc_addresses(self, addresses):
        self.cc_addresses = json.dumps(addresses)
    
    def get_bcc_addresses(self):
        return json.loads(self.bcc_addresses) if self.bcc_addresses else []
    
    def set_bcc_addresses(self, addresses):
        self.bcc_addresses = json.dumps(addresses)
    
    def get_forwarded_emails(self):
        return json.loads(self.forwarded_emails) if self.forwarded_emails else []
    
    def set_forwarded_emails(self, email_ids):
        self.forwarded_emails = json.dumps(email_ids)
    
    def __repr__(self):
        return f"<Email {self.id} - {self.subject}>"

class Thread(Base):
    """Thread model for storing email threads."""
    __tablename__ = 'threads'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    subject = Column(Text)
    date_started = Column(DateTime)
    last_date = Column(DateTime)
    priority = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    # Relationships
    emails = relationship("Email", back_populates="thread")
    categories = relationship("Category", secondary=thread_to_category, back_populates="threads")
    rules = relationship("Rule", secondary=thread_to_rule, back_populates="threads")
    
    def __repr__(self):
        return f"<Thread {self.id} - {self.subject}>"

class Attachment(Base):
    """Attachment model for storing email attachments."""
    __tablename__ = 'attachments'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    filename = Column(String(255), nullable=False)
    content_type = Column(String(100))
    size = Column(Integer)
    hash = Column(String(64), nullable=False, unique=True)  # SHA-256 hash
    storage_path = Column(String(255), nullable=False)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    
    # Relationships
    emails = relationship("Email", secondary=email_to_attachment, back_populates="attachments")
    
    def __repr__(self):
        return f"<Attachment {self.filename}>"

class HtmlObject(Base):
    """HtmlObject model for storing HTML objects (images, etc.)."""
    __tablename__ = 'html_objects'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    original_url = Column(Text)
    content_type = Column(String(100))
    size = Column(Integer)
    hash = Column(String(64), nullable=False, unique=True)  # SHA-256 hash
    storage_path = Column(String(255), nullable=False)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    
    # Relationships
    html_pages = relationship("HtmlPage", secondary=html_page_to_html_object, back_populates="html_objects")
    
    def __repr__(self):
        return f"<HtmlObject {self.id}>"

class Disclaimer(Base):
    """Disclaimer model for storing email disclaimers."""
    __tablename__ = 'disclaimers'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    text = Column(Text, nullable=False)
    hash = Column(String(64), nullable=False, unique=True)  # SHA-256 hash
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    
    # Relationships
    html_pages = relationship("HtmlPage", secondary=html_page_to_disclaimer, back_populates="disclaimers")
    bodies = relationship("Body", secondary=body_to_disclaimer, back_populates="disclaimers")
    emails = relationship("Email", secondary=email_to_disclaimer, back_populates="disclaimers")
    
    def __repr__(self):
        return f"<Disclaimer {self.id}>"

class HtmlPage(Base):
    """HtmlPage model for storing HTML email bodies."""
    __tablename__ = 'html_pages'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    filename = Column(String(255), nullable=False)
    storage_path = Column(String(255), nullable=False)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    
    # Relationships
    emails = relationship("Email", back_populates="html_page")
    html_objects = relationship("HtmlObject", secondary=html_page_to_html_object, back_populates="html_pages")
    disclaimers = relationship("Disclaimer", secondary=html_page_to_disclaimer, back_populates="html_pages")
    
    def __repr__(self):
        return f"<HtmlPage {self.filename}>"

class Body(Base):
    """Body model for storing email text bodies."""
    __tablename__ = 'bodies'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    filename = Column(String(255), nullable=False)
    storage_path = Column(String(255), nullable=False)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    
    # Relationships
    emails = relationship("Email", back_populates="body")
    disclaimers = relationship("Disclaimer", secondary=body_to_disclaimer, back_populates="bodies")
    
    def __repr__(self):
        return f"<Body {self.filename}>"

class Category(Base):
    """Category model for categorizing emails, threads, contacts, and domains."""
    __tablename__ = 'categories'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    name = Column(String(100), nullable=False, unique=True)
    parent_id = Column(String(36), ForeignKey('categories.id'))
    origin = Column(String(1), default='u')  # 'a' for AI, 'u' for user, 'r' for rule, 'i' for AI rule
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    # Relationships
    parent = relationship("Category", remote_side=[id], backref="children")
    emails = relationship("Email", secondary=email_to_category, back_populates="categories")
    threads = relationship("Thread", secondary=thread_to_category, back_populates="categories")
    contacts = relationship("Contact", secondary=contact_to_category, back_populates="categories")
    domains = relationship("Domain", secondary=domain_to_category, back_populates="categories")
    
    def __repr__(self):
        return f"<Category {self.name}>"

class Rule(Base):
    """Rule model for defining email processing rules."""
    __tablename__ = 'rules'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    name = Column(String(100), nullable=False)
    type = Column(String(50), nullable=False)  # 'filter', 'categorize', 'priority', etc.
    targets = Column(Text, nullable=False)  # JSON list of targets (from, to, subject, body, etc.)
    parameters = Column(Text, nullable=False)  # JSON object of parameters
    results = Column(Text, nullable=False)  # JSON object of results
    is_active = Column(Boolean, default=True)
    origin = Column(String(1), default='u')  # 'a' for AI, 'u' for user, 'i' for AI created
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    # Relationships
    emails = relationship("Email", secondary=email_to_rule, back_populates="rules")
    threads = relationship("Thread", secondary=thread_to_rule, back_populates="rules")
    domains = relationship("Domain", secondary=domain_to_rule, back_populates="rules")
    
    def get_targets(self):
        return json.loads(self.targets)
    
    def set_targets(self, targets):
        self.targets = json.dumps(targets)
    
    def get_parameters(self):
        return json.loads(self.parameters)
    
    def set_parameters(self, parameters):
        self.parameters = json.dumps(parameters)
    
    def get_results(self):
        return json.loads(self.results)
    
    def set_results(self, results):
        self.results = json.dumps(results)
    
    def __repr__(self):
        return f"<Rule {self.name}>"

class Keyword(Base):
    """Keyword model for indexing email content."""
    __tablename__ = 'keywords'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    word = Column(String(100), nullable=False, unique=True)
    emails = Column(Text)  # JSON list of email IDs
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    def get_emails(self):
        return json.loads(self.emails) if self.emails else []
    
    def set_emails(self, email_ids):
        self.emails = json.dumps(email_ids)
    
    def __repr__(self):
        return f"<Keyword {self.word}>"

# EMAIL_PROCESSOR.PY
"""
Email Processor module for the Email Organization Application.
This module processes emails, extracts relevant information, and stores them in the database.
"""

import os
import re
import uuid
import hashlib
import json
import datetime
import email
from email import policy
from email.parser import BytesParser
from email.utils import parseaddr, parsedate_to_datetime
import base64
from pathlib import Path
from typing import List, Dict, Any, Tuple, Optional, Set

from bs4 import BeautifulSoup
import magic

from app.models.database_models import (
    Email, Thread, Attachment, HtmlObject, 
    Disclaimer, HtmlPage, Body, Category, Rule
)
from app.database.database_manager import DatabaseManager
from app.email_processing.html_processor import HtmlProcessor
from app.email_processing.attachment_handler import AttachmentHandler
from app.utils.utils import get_config, create_directory_if_not_exists

class EmailProcessor:
    """
    Processes emails, extracts information, and stores them in the database.
    """
    
    def __init__(self, db_manager: DatabaseManager):
        """
        Initialize the EmailProcessor.
        
        Args:
            db_manager: Database manager instance
        """
        self.db_manager = db_manager
        self.config = get_config()
        self.html_processor = HtmlProcessor(db_manager)
        self.attachment_handler = AttachmentHandler(db_manager)
        
        # Create necessary directories
        self.attachments_dir = Path(self.config['storage']['attachments_dir'])
        self.bodies_dir = Path(self.config['storage']['bodies_dir'])
        self.html_objects_dir = Path(self.config['storage']['html_objects_dir'])
        self.emails_dir = Path(self.config['storage']['emails_dir'])
        self.threads_dir = Path(self.config['storage']['threads_dir'])
        self.disclaimers_dir = Path(self.config['storage']['disclaimers_dir'])
        
        create_directory_if_not_exists(self.attachments_dir)
        create_directory_if_not_exists(self.bodies_dir)
        create_directory_if_not_exists(self.html_objects_dir)
        create_directory_if_not_exists(self.emails_dir)
        create_directory_if_not_exists(self.threads_dir)
        create_directory_if_not_exists(self.disclaimers_dir)
        
        # Compile regex patterns for identifying disclaimers
        self.disclaimer_patterns = [
            re.compile(r'CONFIDENTIALITY\s+NOTICE', re.IGNORECASE),
            re.compile(r'DISCLAIMER', re.IGNORECASE),
            re.compile(r'LEGAL\s+NOTICE', re.IGNORECASE),
            re.compile(r'PRIVILEGED\s+AND\s+CONFIDENTIAL', re.IGNORECASE),
            re.compile(r'This\s+email\s+and\s+any\s+attachments\s+are\s+confidential', re.IGNORECASE),
            re.compile(r'This\s+message\s+may\s+contain\s+confidential', re.IGNORECASE),
            re.compile(r'This\s+communication\s+is\s+confidential', re.IGNORECASE),
            re.compile(r'The\s+information\s+contained\s+in\s+this\s+email', re.IGNORECASE),
        ]
    
    def process_email(self, email_data: bytes, account_id: str) -> str:
        """
        Process a raw email and store it in the database.
        
        Args:
            email_data: Raw email data in bytes
            account_id: ID of the email account
            
        Returns:
            ID of the processed email
        """
        # Parse the email
        msg = BytesParser(policy=policy.default).parsebytes(email_data)
        
        # Extract basic email information
        from_address = parseaddr(msg['From'])[1]
        to_addresses = [parseaddr(addr)[1] for addr in msg.get_all('To', [])]
        cc_addresses = [parseaddr(addr)[1] for addr in msg.get_all('Cc', [])]
        bcc_addresses = [parseaddr(addr)[1] for addr in msg.get_all('Bcc', [])]
        subject = msg['Subject'] or ""
        date_sent = parsedate_to_datetime(msg['Date']) if msg['Date'] else datetime.datetime.utcnow()
        message_id = msg['Message-ID'] or str(uuid.uuid4())
        
        # Check if this email already exists in the database
        existing_email = self.db_manager.get_email_by_original_id(message_id)
        if existing_email:
            return existing_email.id
        
        # Determine email format and extract body
        is_html = False
        body_content = ""
        html_content = ""
        
        # Extract body content
        if msg.is_multipart():
            for part in msg.walk():
                content_type = part.get_content_type()
                content_disposition = str(part.get("Content-Disposition", ""))
                
                # Skip attachments
                if "attachment" in content_disposition:
                    continue
                
                if content_type == "text/plain" and not body_content:
                    body_content = part.get_payload(decode=True).decode(errors='replace')
                elif content_type == "text/html" and not html_content:
                    html_content = part.get_payload(decode=True).decode(errors='replace')
                    is_html = True
        else:
            content_type = msg.get_content_type()
            if content_type == "text/plain":
                body_content = msg.get_payload(decode=True).decode(errors='replace')
            elif content_type == "text/html":
                html_content = msg.get_payload(decode=True).decode(errors='replace')
                is_html = True
        
        # If we have HTML content, use it as the primary content
        primary_content = html_content if is_html else body_content
        
        # Process the email content
        email_parts = self.split_email_into_parts(primary_content, is_html)
        
        # Process the main email part
        main_email_part = email_parts[0]
        
        # Extract and store disclaimers
        disclaimers = []
        disclaimer_text = self.extract_disclaimer(main_email_part, is_html)
        if disclaimer_text:
            disclaimer = self.store_disclaimer(disclaimer_text)
            disclaimers.append(disclaimer)
        
        # Store the body or HTML content
        if is_html:
            # Process HTML content
            html_id, processed_html = self.html_processor.process_html(main_email_part, disclaimers)
            body_id = None
        else:
            # Process text content
            body_id = self.store_body(main_email_part, disclaimers)
            html_id = None
        
        # Find or create thread
        thread_id = self.find_or_create_thread(subject, date_sent, from_address, to_addresses)
        
        # Process attachments
        attachments = self.process_attachments(msg)
        
        # Create email record
        email_id = str(uuid.uuid4())
        
        # Check for forwarded emails in the content
        forwarded_emails = []
        if len(email_parts) > 1:
            for part in email_parts[1:]:
                forwarded_email_id = self.process_forwarded_email(part, is_html, thread_id)
                if forwarded_email_id:
                    forwarded_emails.append(forwarded_email_id)
        
        # Create the email object
        email_obj = Email(
            id=email_id,
            original_id=message_id,
            from_address=from_address,
            to_addresses=json.dumps(to_addresses),
            cc_addresses=json.dumps(cc_addresses) if cc_addresses else None,
            bcc_addresses=json.dumps(bcc_addresses) if bcc_addresses else None,
            subject=subject,
            format="html" if is_html else "text",
            date_sent=date_sent,
            body_id=body_id,
            html_id=html_id,
            thread_id=thread_id,
            forwarded_emails=json.dumps(forwarded_emails) if forwarded_emails else None
        )
        
        # Save the email to the database
        self.db_manager.add_email(email_obj)
        
        # Associate attachments with the email
        for attachment in attachments:
            self.db_manager.add_email_attachment(email_id, attachment.id)
        
        # Associate disclaimers with the email
        for disclaimer in disclaimers:
            self.db_manager.add_email_disclaimer(email_id, disclaimer.id)
        
        # Update thread last_date
        self.db_manager.update_thread_last_date(thread_id, date_sent)
        
        # Apply rules to the email
        self.apply_rules_to_email(email_obj)
        
        return email_id
    
    def split_email_into_parts(self, content: str, is_html: bool) -> List[str]:
        """
        Split an email into parts based on forwarded content.
        
        Args:
            content: Email content
            is_html: Whether the content is HTML
            
        Returns:
            List of email parts
        """
        if is_html:
            return self.split_html_email(content)
        else:
            return self.split_text_email(content)
    
    def split_text_email(self, content: str) -> List[str]:
        """
        Split a text email into parts based on forwarded content.
        
        Args:
            content: Email content
            
        Returns:
            List of email parts
        """
        # Common patterns for forwarded emails
        patterns = [
            r'(?m)^-{3,}[\s]*Forwarded message[\s]*-{3,}',
            r'(?m)^From:[\s]*[^\n]+\nDate:[\s]*[^\n]+\nSubject:[\s]*[^\n]+\nTo:[\s]*[^\n]+',
            r'(?m)^On[\s]+[^,]+,[\s]+[^<]+<[^>]+>[\s]+wrote:',
            r'(?m)^-{3,}[\s]*Original Message[\s]*-{3,}',
        ]
        
        # Find all potential split points
        split_points = []
        for pattern in patterns:
            for match in re.finditer(pattern, content):
                split_points.append(match.start())
        
        # Sort split points
        split_points.sort()
        
        # Split the content
        if not split_points:
            return [content]
        
        parts = []
        start = 0
        for point in split_points:
            parts.append(content[start:point].strip())
            start = point
        
        # Add the last part
        parts.append(content[start:].strip())
        
        return parts
    
    def split_html_email(self, content: str) -> List[str]:
        """
        Split an HTML email into parts based on forwarded content.
        
        Args:
            content: Email content
            
        Returns:
            List of email parts
        """
        soup = BeautifulSoup(content, 'html.parser')
        
        # Look for common forwarded email indicators
        forwarded_indicators = [
            'Forwarded message',
            'Original Message',
            'Begin forwarded message',
            'From:',
            'Date:',
            'Subject:',
            'To:'
        ]
        
        # Find potential split points
        split_elements = []
        
        # Check for blockquote elements (common for forwarded content)
        blockquotes = soup.find_all('blockquote')
        split_elements.extend(blockquotes)
        
        # Check for divs with specific classes or styles
        divs = soup.find_all('div', class_=lambda c: c and ('gmail_quote' in c or 'ms-outlook' in c))
        split_elements.extend(divs)
        
        # Check for hr elements
        hrs = soup.find_all('hr')
        split_elements.extend(hrs)
        
        # If no structural elements found, look for text indicators
        if not split_elements:
            for indicator in forwarded_indicators:
                elements = soup.find_all(text=lambda t: indicator in t)
                for element in elements:
                    parent = element.parent
                    if parent not in split_elements:
                        split_elements.append(parent)
        
        # If still no split points, return the whole content
        if not split_elements:
            return [content]
        
        # Extract the main content and the forwarded parts
        parts = [content]
        
        # For each split element, create a new part
        for element in split_elements:
            # Create a new document for this part
            part_soup = BeautifulSoup('<html><body></body></html>', 'html.parser')
            
            # Add all siblings of the element to the new document
            current = element
            while current:
                next_sibling = current.next_sibling
                current.extract()
                part_soup.body.append(current)
                current = next_sibling
            
            parts.append(str(part_soup))
        
        return parts
    
    def extract_disclaimer(self, content: str, is_html: bool) -> Optional[str]:
        """
        Extract disclaimer from email content.
        
        Args:
            content: Email content
            is_html: Whether the content is HTML
            
        Returns:
            Extracted disclaimer text or None
        """
        if is_html:
            return self.extract_html_disclaimer(content)
        else:
            return self.extract_text_disclaimer(content)
    
    def extract_text_disclaimer(self, content: str) -> Optional[str]:
        """
        Extract disclaimer from text email content.
        
        Args:
            content: Email content
            
        Returns:
            Extracted disclaimer text or None
        """
        for pattern in self.disclaimer_patterns:
            match = pattern.search(content)
            if match:
                # Extract from the match to the end of the content
                return content[match.start():].strip()
        
        return None
    
    def extract_html_disclaimer(self, content: str) -> Optional[str]:
        """
        Extract disclaimer from HTML email content.
        
        Args:
            content: Email content
            
        Returns:
            Extracted disclaimer text or None
        """
        soup = BeautifulSoup(content, 'html.parser')
        
        # Convert HTML to text for pattern matching
        text_content = soup.get_text()
        
        for pattern in self.disclaimer_patterns:
            match = pattern.search(text_content)
            if match:
                # Find the HTML element containing the disclaimer
                disclaimer_text = text_content[match.start():].strip()
                
                # Try to find the corresponding HTML element
                for element in soup.find_all(text=lambda t: t and pattern.search(t)):
                    parent = element.parent
                    # Extract the parent element and all its siblings
                    disclaimer_html = str(parent)
                    return disclaimer_html
        
        return None
    
    def store_disclaimer(self, disclaimer_text: str) -> Any:
        """
        Store a disclaimer in the database.
        
        Args:
            disclaimer_text: Disclaimer text
            
        Returns:
            Disclaimer object
        """
        # Create a hash of the disclaimer text
        disclaimer_hash = hashlib.sha256(disclaimer_text.encode()).hexdigest()
        
        # Check if this disclaimer already exists
        disclaimer = self.db_manager.get_disclaimer_by_hash(disclaimer_hash)
        if disclaimer:
            return disclaimer
        
        # Create a new disclaimer
        disclaimer_id = str(uuid.uuid4())
        disclaimer = Disclaimer(
            id=disclaimer_id,
            text=disclaimer_text,
            hash=disclaimer_hash
        )
        
        # Save the disclaimer to the database
        self.db_manager.add_disclaimer(disclaimer)
        
        return disclaimer
    
    def store_body(self, body_content: str, disclaimers: List[Any]) -> str:
        """
        Store email body content.
        
        Args:
            body_content: Body content
            disclaimers: List of disclaimers
            
        Returns:
            ID of the stored body
        """
        # Generate a unique ID for the body
        body_id = str(uuid.uuid4())
        
        # Create the filename
        filename = f"{body_id}.bod"
        storage_path = str(self.bodies_dir / filename)
        
        # Write the body content to file
        with open(storage_path, 'w', encoding='utf-8') as f:
            f.write(body_content)
        
        # Create the body object
        body = Body(
            id=body_id,
            filename=filename,
            storage_path=storage_path
        )
        
        # Save the body to the database
        self.db_manager.add_body(body)
        
        # Associate disclaimers with the body
        for disclaimer in disclaimers:
            self.db_manager.add_body_disclaimer(body_id, disclaimer.id)
        
        return body_id
    
    def find_or_create_thread(self, subject: str, date: datetime.datetime, 
                             from_address: str, to_addresses: List[str]) -> str:
        """
        Find an existing thread or create a new one.
        
        Args:
            subject: Email subject
            date: Email date
            from_address: Sender address
            to_addresses: Recipient addresses
            
        Returns:
            Thread ID
        """
        # Clean the subject by removing prefixes like Re:, Fwd:, etc.
        clean_subject = re.sub(r'^(?:Re|Fwd|Fw|Forward):\s*', '', subject, flags=re.IGNORECASE)
        
        # Look for an existing thread with this subject
        thread = self.db_manager.get_thread_by_subject(clean_subject)
        
        if thread:
            return thread.id
        
        # Create a new thread
        thread_id = str(uuid.uuid4())
        thread = Thread(
            id=thread_id,
            subject=clean_subject,
            date_started=date,
            last_date=date
        )
        
        # Save the thread to the database
        self.db_manager.add_thread(thread)
        
        return thread_id
    
    def process_attachments(self, msg: email.message.Message) -> List[Any]:
        """
        Process email attachments.
        
        Args:
            msg: Email message
            
        Returns:
            List of attachment objects
        """
        attachments = []
        
        for part in msg.walk():
            content_disposition = str(part.get("Content-Disposition", ""))
            
            if "attachment" not in content_disposition:
                continue
            
            filename = part.get_filename()
            if not filename:
                continue
            
            # Get the attachment data
            attachment_data = part.get_payload(decode=True)
            if not attachment_data:
                continue
            
            # Process the attachment
            attachment = self.attachment_handler.process_attachment(filename, attachment_data)
            if attachment:
                attachments.append(attachment)
        
        return attachments
    
    def process_forwarded_email(self, content: str, is_html: bool, thread_id: str) -> Optional[str]:
        """
        Process a forwarded email part.
        
        Args:
            content: Email content
            is_html: Whether the content is HTML
            thread_id: Thread ID
            
        Returns:
            ID of the processed email or None
        """
        # Extract email information from the forwarded content
        if is_html:
            email_info = self.extract_email_info_from_html(content)
        else:
            email_info = self.extract_email_info_from_text(content)
        
        if not email_info:
            return None
        
        # Check if this email already exists
        from_address = email_info.get('from')
        subject = email_info.get('subject')
        date_str = email_info.get('date')
        
        if not from_address or not subject:
            return None
        
        # Parse the date
        date = None
        if date_str:
            try:
                date = parsedate_to_datetime(date_str)
            except:
                date = datetime.datetime.utcnow()
        else:
            date = datetime.datetime.utcnow()
        
        # Check for duplicate emails
        existing_email = self.db_manager.get_email_by_details(from_address, subject, date)
        if existing_email:
            return existing_email.id
        
        # Process the content
        disclaimers = []
        disclaimer_text = self.extract_disclaimer(content, is_html)
        if disclaimer_text:
            disclaimer = self.store_disclaimer(disclaimer_text)
            disclaimers.append(disclaimer)
        
        # Store the content
        if is_html:
            # Process HTML content
            html_id, processed_html = self.html_processor.process_html(content, disclaimers)
            body_id = None
        else:
            # Process text content
            body_id = self.store_body(content, disclaimers)
            html_id = None
        
        # Create the email object
        email_id = str(uuid.uuid4())
        to_addresses = email_info.get('to', [])
        cc_addresses = email_info.get('cc', [])
        
        email_obj = Email(
            id=email_id,
            original_id=str(uuid.uuid4()),  # Generate a new ID for the forwarded email
            from_address=from_address,
            to_addresses=json.dumps(to_addresses) if to_addresses else json.dumps([]),
            cc_addresses=json.dumps(cc_addresses) if cc_addresses else None,
            bcc_addresses=None,
            subject=subject,
            format="html" if is_html else "text",
            date_sent=date,
            body_id=body_id,
            html_id=html_id,
            thread_id=thread_id
        )
        
        # Save the email to the database
        self.db_manager.add_email(email_obj)
        
        # Associate disclaimers with the email
        for disclaimer in disclaimers:
            self.db_manager.add_email_disclaimer(email_id, disclaimer.id)
        
        return email_id
    
    def extract_email_info_from_text(self, content: str) -> Dict[str, Any]:
        """
        Extract email information from text content.
        
        Args:
            content: Email content
            
        Returns:
            Dictionary with email information
        """
        email_info = {}
        
        # Extract From
        from_match = re.search(r'From:\s*([^\n]+)', content)
        if from_match:
            email_info['from'] = parseaddr(from_match.group(1))[1]
        
        # Extract To
        to_match = re.search(r'To:\s*([^\n]+)', content)
        if to_match:
            to_str = to_match.group(1)
            email_info['to'] = [parseaddr(addr)[1] for addr in to_str.split(',')]
        
        # Extract Cc
        cc_match = re.search(r'Cc:\s*([^\n]+)', content)
        if cc_match:
            cc_str = cc_match.group(1)
            email_info['cc'] = [parseaddr(addr)[1] for addr in cc_str.split(',')]
        
        # Extract Subject
        subject_match = re.search(r'Subject:\s*([^\n]+)', content)
        if subject_match:
            email_info['subject'] = subject_match.group(1).strip()
        
        # Extract Date
        date_match = re.search(r'Date:\s*([^\n]+)', content)
        if date_match:
            email_info['date'] = date_match.group(1).strip()
        
        return email_info
    
    def extract_email_info_from_html(self, content: str) -> Dict[str, Any]:
        """
        Extract email information from HTML content.
        
        Args:
            content: Email content
            
        Returns:
            Dictionary with email information
        """
        soup = BeautifulSoup(content, 'html.parser')
        text_content = soup.get_text()
        
        # Use the text extraction method
        return self.extract_email_info_from_text(text_content)
    
    def apply_rules_to_email(self, email_obj: Email) -> None:
        """
        Apply rules to an email.
        
        Args:
            email_obj: Email object
        """
        # Get all active rules
        rules = self.db_manager.get_active_rules()
        
        for rule in rules:
            # Get rule details
            rule_type = rule.type
            targets = rule.get_targets()
            parameters = rule.get_parameters()
            results = rule.get_results()
            
            # Check if the rule applies to this email
            if self.rule_applies_to_email(email_obj, targets, parameters):
                # Apply the rule
                self.apply_rule(email_obj, rule, results)
    
    def rule_applies_to_email(self, email_obj: Email, targets: List[str], 
                             parameters: Dict[str, Any]) -> bool:
        """
        Check if a rule applies to an email.
        
        Args:
            email_obj: Email object
            targets: Rule targets
            parameters: Rule parameters
            
        Returns:
            True if the rule applies, False otherwise
        """
        for target in targets:
            if target == 'from':
                # Check sender
                pattern = parameters.get('from_pattern')
                if pattern and re.search(pattern, email_obj.from_address, re.IGNORECASE):
                    return True
            
            elif target == 'to':
                # Check recipients
                pattern = parameters.get('to_pattern')
                if pattern:
                    for to_addr in email_obj.get_to_addresses():
                        if re.search(pattern, to_addr, re.IGNORECASE):
                            return True
            
            elif target == 'subject':
                # Check subject
                pattern = parameters.get('subject_pattern')
                if pattern and email_obj.subject and re.search(pattern, email_obj.subject, re.IGNORECASE):
                    return True
            
            elif target == 'body':
                # Check body content
                pattern = parameters.get('body_pattern')
                if pattern:
                    # Get the body content
                    body_content = ""
                    if email_obj.body_id:
                        body = self.db_manager.get_body(email_obj.body_id)
                        if body:
                            with open(body.storage_path, 'r', encoding='utf-8') as f:
                                body_content = f.read()
                    
                    if body_content and re.search(pattern, body_content, re.IGNORECASE):
                        return True
        
        return False
    
    def apply_rule(self, email_obj: Email, rule: Rule, results: Dict[str, Any]) -> None:
        """
        Apply a rule to an email.
        
        Args:
            email_obj: Email object
            rule: Rule object
            results: Rule results
        """
        rule_type = rule.type
        
        if rule_type == 'categorize':
            # Add category to email
            category_id = results.get('category_id')
            if category_id:
                self.db_manager.add_email_category(email_obj.id, category_id)
                
                # Also add to thread
                if email_obj.thread_id:
                    self.db_manager.add_thread_category(email_obj.thread_id, category_id)
        
        elif rule_type == 'priority':
            # Set email priority
            priority = results.get('priority')
            if priority is not None:
                self.db_manager.update_email_priority(email_obj.id, priority)
                
                # Also update thread priority
                if email_obj.thread_id:
                    self.db_manager.update_thread_priority(email_obj.thread_id, priority)
        
        # Associate the rule with the email
        self.db_manager.add_email_rule(email_obj.id, rule.id)
        
        # If the email is part of a thread, also associate the rule with the thread
        if email_obj.thread_id:
            self.db_manager.add_thread_rule(email_obj.thread_id, rule.id)

# HTML_PROCESSOR.PY
"""
HTML Processor module for the Email Organization Application.
This module processes HTML email content, extracts embedded objects, and stores them.
"""

import os
import re
import uuid
import hashlib
from pathlib import Path
from typing import List, Dict, Any, Tuple, Optional, Set
import base64
import urllib.parse

from bs4 import BeautifulSoup
import magic
import requests
from PIL import Image
from io import BytesIO

from app.models.database_models import HtmlObject, HtmlPage, Disclaimer
from app.database.database_manager import DatabaseManager
from app.utils.utils import get_config, create_directory_if_not_exists

class HtmlProcessor:
    """
    Processes HTML email content, extracts embedded objects, and stores them.
    """
    
    def __init__(self, db_manager: DatabaseManager):
        """
        Initialize the HtmlProcessor.
        
        Args:
            db_manager: Database manager instance
        """
        self.db_manager = db_manager
        self.config = get_config()
        
        # Create necessary directories
        self.html_objects_dir = Path(self.config['storage']['html_objects_dir'])
        create_directory_if_not_exists(self.html_objects_dir)
    
    def process_html(self, html_content: str, disclaimers: List[Any]) -> Tuple[str, str]:
        """
        Process HTML content, extract and store embedded objects.
        
        Args:
            html_content: HTML content
            disclaimers: List of disclaimers
            
        Returns:
            Tuple of (html_id, processed_html)
        """
        # Parse the HTML
        soup = BeautifulSoup(html_content, 'html.parser')
        
        # Process images
        processed_html, html_objects = self.process_images(soup)
        
        # Process other embedded objects (if any)
        # This could include embedded stylesheets, scripts, etc.
        
        # Generate a unique ID for the HTML page
        html_id = str(uuid.uuid4())
        
        # Create the filename
        filename = f"{html_id}.hbod"
        storage_path = str(Path(self.config['storage']['bodies_dir']) / filename)
        
        # Write the processed HTML to file
        with open(storage_path, 'w', encoding='utf-8') as f:
            f.write(processed_html)
        
        # Create the HTML page object
        html_page = HtmlPage(
            id=html_id,
            filename=filename,
            storage_path=storage_path
        )
        
        # Save the HTML page to the database
        self.db_manager.add_html_page(html_page)
        
        # Associate HTML objects with the HTML page
        for html_object in html_objects:
            self.db_manager.add_html_page_html_object(html_id, html_object.id)
        
        # Associate disclaimers with the HTML page
        for disclaimer in disclaimers:
            self.db_manager.add_html_page_disclaimer(html_id, disclaimer.id)
        
        return html_id, processed_html
    
    def process_images(self, soup: BeautifulSoup) -> Tuple[str, List[Any]]:
        """
        Process images in HTML content.
        
        Args:
            soup: BeautifulSoup object
            
        Returns:
            Tuple of (processed_html, list of html_objects)
        """
        html_objects = []
        
        # Find all image tags
        img_tags = soup.find_all('img')
        
        for img in img_tags:
            # Get the image source
            src = img.get('src')
            if not src:
                continue
            
            # Process the image
            html_object = None
            
            # Check if it's a base64 encoded image
            if src.startswith('data:image'):
                html_object = self.process_base64_image(src)
            # Check if it's a URL
            elif src.startswith(('http://', 'https://')):
                html_object = self.process_url_image(src)
            # Check if it's a local file path
            elif src.startswith(('/', './')):
                # Skip local files for now
                continue
            # Check if it's a CID reference
            elif src.startswith('cid:'):
                # This will be handled separately by the email processor
                continue
            
            if html_object:
                # Update the image src to point to the stored object
                img['src'] = f"../html_objects/{html_object.storage_path.split('/')[-1]}"
                html_objects.append(html_object)
        
        # Return the processed HTML and the list of HTML objects
        return str(soup), html_objects
    
    def process_base64_image(self, src: str) -> Optional[Any]:
        """
        Process a base64 encoded image.
        
        Args:
            src: Image source
            
        Returns:
            HtmlObject or None
        """
        try:
            # Extract the content type and base64 data
            content_type = src.split(';')[0].split(':')[1]
            base64_data = src.split(',')[1]
            
            # Decode the base64 data
            image_data = base64.b64decode(base64_data)
            
            # Process the image data
            return self.store_html_object(image_data, content_type, None)
        except Exception as e:
            print(f"Error processing base64 image: {e}")
            return None
    
    def process_url_image(self, url: str) -> Optional[Any]:
        """
        Process an image from a URL.
        
        Args:
            url: Image URL
            
        Returns:
            HtmlObject or None
        """
        try:
            # Download the image
            response = requests.get(url, timeout=10)
            if response.status_code != 200:
                return None
            
            # Get the content type
            content_type = response.headers.get('Content-Type', 'application/octet-stream')
            
            # Process the image data
            return self.store_html_object(response.content, content_type, url)
        except Exception as e:
            print(f"Error processing URL image: {e}")
            return None
    
    def store_html_object(self, data: bytes, content_type: str, original_url: Optional[str]) -> Optional[Any]:
        """
        Store an HTML object.
        
        Args:
            data: Object data
            content_type: Content type
            original_url: Original URL
            
        Returns:
            HtmlObject or None
        """
        try:
            # Create a hash of the data
            data_hash = hashlib.sha256(data).hexdigest()
            
            # Check if this object already exists
            html_object = self.db_manager.get_html_object_by_hash(data_hash)
            if html_object:
                return html_object
            
            # Generate a unique ID for the object
            object_id = str(uuid.uuid4())
            
            # Determine the file extension
            ext = self.get_file_extension(content_type, data)
            
            # Create the filename
            filename = f"{object_id}.{ext}"
            storage_path = str(self.html_objects_dir / filename)
            
            # Write the data to file
            with open(storage_path, 'wb') as f:
                f.write(data)
            
            # Create the HTML object
            html_object = HtmlObject(
                id=object_id,
                original_url=original_url,
                content_type=content_type,
                size=len(data),
                hash=data_hash,
                storage_path=storage_path
            )
            
            # Save the HTML object to the database
            self.db_manager.add_html_object(html_object)
            
            return html_object
        except Exception as e:
            print(f"Error storing HTML object: {e}")
            return None
    
    def get_file_extension(self, content_type: str, data: bytes) -> str:
        """
        Determine the file extension based on content type and data.
        
        Args:
            content_type: Content type
            data: File data
            
        Returns:
            File extension
        """
        # Try to determine the extension from the content type
        content_type_map = {
            'image/jpeg': 'jpg',
            'image/png': 'png',
            'image/gif': 'gif',
            'image/bmp': 'bmp',
            'image/webp': 'webp',
            'image/svg+xml': 'svg',
            'text/css': 'css',
            'application/javascript': 'js',
            'text/javascript': 'js'
        }
        
        ext = content_type_map.get(content_type.lower())
        if ext:
            return ext
        
        # If the content type doesn't provide a clear extension, use magic to detect the file type
        try:
            mime = magic.Magic(mime=True)
            detected_type = mime.from_buffer(data)
            ext = content_type_map.get(detected_type.lower())
            if ext:
                return ext
        except:
            pass
        
        # If all else fails, try to determine from the data itself
        if content_type.startswith('image/'):
            try:
                img = Image.open(BytesIO(data))
                return img.format.lower()
            except:
                return 'img'
        
        # Default extension
        return 'bin'

# ATTACHMENT_HANDLER.PY
"""
Attachment Handler module for the Email Organization Application.
This module processes email attachments and stores them.
"""

import os
import uuid
import hashlib
from pathlib import Path
from typing import Optional, Any

import magic

from app.models.database_models import Attachment
from app.database.database_manager import DatabaseManager
from app.utils.utils import get_config, create_directory_if_not_exists

class AttachmentHandler:
    """
    Processes email attachments and stores them.
    """
    
    def __init__(self, db_manager: DatabaseManager):
        """
        Initialize the AttachmentHandler.
        
        Args:
            db_manager: Database manager instance
        """
        self.db_manager = db_manager
        self.config = get_config()
        
        # Create necessary directories
        self.attachments_dir = Path(self.config['storage']['attachments_dir'])
        create_directory_if_not_exists(self.attachments_dir)
    
    def process_attachment(self, filename: str, data: bytes) -> Optional[Any]:
        """
        Process an email attachment.
        
        Args:
            filename: Attachment filename
            data: Attachment data
            
        Returns:
            Attachment object or None
        """
        try:
            # Create a hash of the data
            data_hash = hashlib.sha256(data).hexdigest()
            
            # Check if this attachment already exists
            attachment = self.db_manager.get_attachment_by_hash(data_hash)
            if attachment:
                return attachment
            
            # Determine the content type
            try:
                mime = magic.Magic(mime=True)
                content_type = mime.from_buffer(data)
            except:
                content_type = "application/octet-stream"
            
            # Generate a unique ID for the attachment
            attachment_id = str(uuid.uuid4())
            
            # Create the storage path
            storage_path = str(self.attachments_dir / f"{attachment_id}_{filename}")
            
            # Write the data to file
            with open(storage_path, 'wb') as f:
                f.write(data)
            
            # Create the attachment object
            attachment = Attachment(
                id=attachment_id,
                filename=filename,
                content_type=content_type,
                size=len(data),
                hash=data_hash,
                storage_path=storage_path
            )
            
            # Save the attachment to the database
            self.db_manager.add_attachment(attachment)
            
            return attachment
        except Exception as e:
            print(f"Error processing attachment: {e}")
            return None

# EMAIL_RETRIEVER.PY
"""
Email Retriever module for the Email Organization Application.
This module retrieves emails from various email providers (Exchange, Gmail, etc.).
"""

import os
import datetime
from typing import List, Dict, Any, Optional, Tuple
import base64
import json

# Exchange Online / Microsoft 365
from exchangelib import Credentials, Account, Configuration, DELEGATE, EWSDateTime, EWSTimeZone, Q

# Gmail
from google.oauth2.credentials import Credentials as GoogleCredentials
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build

from app.email_processing.email_processor import EmailProcessor
from app.database.database_manager import DatabaseManager
from app.utils.utils import get_config, decrypt_credentials

class EmailRetriever:
    """
    Retrieves emails from various email providers.
    """
    
    def __init__(self, db_manager: DatabaseManager, email_processor: EmailProcessor):
        """
        Initialize the EmailRetriever.
        
        Args:
            db_manager: Database manager instance
            email_processor: Email processor instance
        """
        self.db_manager = db_manager
        self.email_processor = email_processor
        self.config = get_config()
    
    def retrieve_emails(self, account_id: str, filters: Dict[str, Any] = None) -> List[str]:
        """
        Retrieve emails from an email account.
        
        Args:
            account_id: Email account ID
            filters: Optional filters for retrieving emails
            
        Returns:
            List of processed email IDs
        """
        # Get the email account
        account = self.db_manager.get_email_account(account_id)
        if not account:
            raise ValueError(f"Email account with ID {account_id} not found")
        
        # Decrypt the credentials
        credentials = decrypt_credentials(account.encrypted_credentials)
        
        # Retrieve emails based on account type
        if account.account_type == 'exchange':
            return self.retrieve_exchange_emails(account, credentials, filters)
        elif account.account_type == 'gmail':
            return self.retrieve_gmail_emails(account, credentials, filters)
        else:
            raise ValueError(f"Unsupported account type: {account.account_type}")
    
    def retrieve_exchange_emails(self, account: Any, credentials: Dict[str, str], 
                                filters: Dict[str, Any] = None) -> List[str]:
        """
        Retrieve emails from an Exchange account.
        
        Args:
            account: Email account object
            credentials: Decrypted credentials
            filters: Optional filters for retrieving emails
            
        Returns:
            List of processed email IDs
        """
        # Set up Exchange credentials
        exchange_credentials = Credentials(
            username=credentials.get('username'),
            password=credentials.get('password')
        )
        
        # Set up Exchange configuration
        config = Configuration(
            server=credentials.get('server', 'outlook.office365.com'),
            credentials=exchange_credentials
        )
        
        # Connect to the Exchange account
        exchange_account = Account(
            primary_smtp_address=account.email_address,
            config=config,
            access_type=DELEGATE
        )
        
        # Build the query based on filters
        query = self.build_exchange_query(filters)
        
        # Get the batch size
        batch_size = self.config['email']['batch_size']
        
        # Retrieve emails
        processed_email_ids = []
        
        # Get the emails
        emails = exchange_account.inbox.filter(query).order_by('-datetime_received')[:batch_size]
        
        for email in emails:
            # Get the email as bytes
            email_bytes = email.mime_content
            
            # Process the email
            email_id = self.email_processor.process_email(email_bytes, account.id)
            processed_email_ids.append(email_id)
        
        # Update the last sync time
        self.db_manager.update_email_account_last_sync(account.id, datetime.datetime.utcnow())
        
        return processed_email_ids
    
    def build_exchange_query(self, filters: Dict[str, Any] = None) -> Q:
        """
        Build an Exchange query based on filters.
        
        Args:
            filters: Optional filters for retrieving emails
            
        Returns:
            Exchange query
        """
        if not filters:
            return Q()
        
        query = Q()
        
        # Date range filter
        if 'start_date' in filters:
            tz = EWSTimeZone.localzone()
            start_date = EWSDateTime.from_datetime(filters['start_date'].replace(tzinfo=tz))
            query &= Q(datetime_received__gte=start_date)
        
        if 'end_date' in filters:
            tz = EWSTimeZone.localzone()
            end_date = EWSDateTime.from_datetime(filters['end_date'].replace(tzinfo=tz))
            query &= Q(datetime_received__lte=end_date)
        
        # Sender filter
        if 'from' in filters:
            query &= Q(sender__contains=filters['from'])
        
        # Recipient filter
        if 'to' in filters:
            query &= Q(to_recipients__contains=filters['to'])
        
        # Subject filter
        if 'subject' in filters:
            query &= Q(subject__contains=filters['subject'])
        
        # Body filter
        if 'body' in filters:
            query &= Q(body__contains=filters['body'])
        
        return query
    
    def retrieve_gmail_emails(self, account: Any, credentials: Dict[str, str], 
                             filters: Dict[str, Any] = None) -> List[str]:
        """
        Retrieve emails from a Gmail account.
        
        Args:
            account: Email account object
            credentials: Decrypted credentials
            filters: Optional filters for retrieving emails
            
        Returns:
            List of processed email IDs
        """
        # Set up Gmail credentials
        token = credentials.get('token')
        if not token:
            raise ValueError("Gmail token not found in credentials")
        
        # Load the token
        creds = GoogleCredentials.from_authorized_user_info(json.loads(token))
        
        # If the token is expired, refresh it
        if creds.expired and creds.refresh_token:
            creds.refresh(Request())
            
            # Update the credentials in the database
            updated_credentials = {
                'token': json.dumps(creds.to_json())
            }
            self.db_manager.update_email_account_credentials(account.id, updated_credentials)
        
        # Build the Gmail service
        service = build('gmail', 'v1', credentials=creds)
        
        # Build the query based on filters
        query = self.build_gmail_query(filters)
        
        # Get the batch size
        batch_size = self.config['email']['batch_size']
        
        # Retrieve emails
        processed_email_ids = []
        
        # Get the emails
        results = service.users().messages().list(userId='me', q=query, maxResults=batch_size).execute()
        messages = results.get('messages', [])
        
        for message in messages:
            # Get the email details
            msg = service.users().messages().get(userId='me', id=message['id'], format='raw').execute()
            
            # Decode the email
            email_bytes = base64.urlsafe_b64decode(msg['raw'])
            
            # Process the email
            email_id = self.email_processor.process_email(email_bytes, account.id)
            processed_email_ids.append(email_id)
        
        # Update the last sync time
        self.db_manager.update_email_account_last_sync(account.id, datetime.datetime.utcnow())
        
        return processed_email_ids
    
    def build_gmail_query(self, filters: Dict[str, Any] = None) -> str:
        """
        Build a Gmail query based on filters.
        
        Args:
            filters: Optional filters for retrieving emails
            
        Returns:
            Gmail query string
        """
        if not filters:
            return ''
        
        query_parts = []
        
        # Date range filter
        if 'start_date' in filters:
            start_date_str = filters['start_date'].strftime('%Y/%m/%d')
            query_parts.append(f"after:{start_date_str}")
        
        if 'end_date' in filters:
            end_date_str = filters['end_date'].strftime('%Y/%m/%d')
            query_parts.append(f"before:{end_date_str}")
        
        # Sender filter
        if 'from' in filters:
            query_parts.append(f"from:{filters['from']}")
        
        # Recipient filter
        if 'to' in filters:
            query_parts.append(f"to:{filters['to']}")
        
        # Subject filter
        if 'subject' in filters:
            query_parts.append(f"subject:{filters['subject']}")
        
        # Body filter
        if 'body' in filters:
            query_parts.append(f"{filters['body']}")
        
        return ' '.join(query_parts)
    
    def sync_all_accounts(self) -> Dict[str, List[str]]:
        """
        Sync all active email accounts.
        
        Returns:
            Dictionary mapping account IDs to lists of processed email IDs
        """
        # Get all active email accounts
        accounts = self.db_manager.get_active_email_accounts()
        
        results = {}
        
        for account in accounts:
            try:
                # Get the last sync time
                last_sync = account.last_sync
                
                # Set up filters to only get emails since the last sync
                filters = {}
                if last_sync:
                    filters['start_date'] = last_sync
                
                # Retrieve emails
                email_ids = self.retrieve_emails(account.id, filters)
                results[account.id] = email_ids
            except Exception as e:
                print(f"Error syncing account {account.id}: {e}")
                results[account.id] = []
        
        return results

# THREAD_MANAGER.PY
"""
Thread Manager module for the Email Organization Application.
This module manages email threads, reconstructs them, and provides thread-related operations.
"""

import os
import datetime
import json
from typing import List, Dict, Any, Optional, Set
from pathlib import Path

from app.models.database_models import Email, Thread, Attachment
from app.database.database_manager import DatabaseManager
from app.utils.utils import get_config

class ThreadManager:
    """
    Manages email threads, reconstructs them, and provides thread-related operations.
    """
    
    def __init__(self, db_manager: DatabaseManager):
        """
        Initialize the ThreadManager.
        
        Args:
            db_manager: Database manager instance
        """
        self.db_manager = db_manager
        self.config = get_config()
    
    def get_thread(self, thread_id: str) -> Dict[str, Any]:
        """
        Get a thread and its emails.
        
        Args:
            thread_id: Thread ID
            
        Returns:
            Dictionary with thread information and emails
        """
        # Get the thread
        thread = self.db_manager.get_thread(thread_id)
        if not thread:
            raise ValueError(f"Thread with ID {thread_id} not found")
        
        # Get the emails in the thread
        emails = self.db_manager.get_emails_by_thread(thread_id)
        
        # Sort emails by date
        emails.sort(key=lambda x: x.date_sent)
        
        # Get thread categories
        categories = self.db_manager.get_thread_categories(thread_id)
        
        # Get thread rules
        rules = self.db_manager.get_thread_rules(thread_id)
        
        # Build the thread information
        thread_info = {
            'id': thread.id,
            'subject': thread.subject,
            'date_started': thread.date_started,
            'last_date': thread.last_date,
            'priority': thread.priority,
            'categories': [{'id': cat.id, 'name': cat.name} for cat in categories],
            'rules': [{'id': rule.id, 'name': rule.name, 'type': rule.type} for rule in rules],
            'emails': []
        }
        
        # Add email information
        for email in emails:
            email_info = self.get_email_info(email)
            thread_info['emails'].append(email_info)
        
        return thread_info
    
    def get_email_info(self, email: Email) -> Dict[str, Any]:
        """
        Get information about an email.
        
        Args:
            email: Email object
            
        Returns:
            Dictionary with email information
        """
        # Get email categories
        categories = self.db_manager.get_email_categories(email.id)
        
        # Get email attachments
        attachments = self.db_manager.get_email_attachments(email.id)
        
        # Get email disclaimers
        disclaimers = self.db_manager.get_email_disclaimers(email.id)
        
        # Build the email information
        email_info = {
            'id': email.id,
            'from': email.from_address,
            'to': email.get_to_addresses(),
            'cc': email.get_cc_addresses(),
            'bcc': email.get_bcc_addresses(),
            'subject': email.subject,
            'date_sent': email.date_sent,
            'format': email.format,
            'priority': email.priority,
            'spam_score': email.spam_score,
            'confidential': email.confidential,
            'categories': [{'id': cat.id, 'name': cat.name} for cat in categories],
            'attachments': [{'id': att.id, 'filename': att.filename, 'size': att.size} for att in attachments],
            'disclaimers': [{'id': disc.id} for disc in disclaimers],
            'forwarded_emails': email.get_forwarded_emails() if hasattr(email, 'get_forwarded_emails') and callable(getattr(email, 'get_forwarded_emails')) else []
        }
        
        return email_info
    
    def reconstruct_thread(self, thread_id: str, include_content: bool = True) -> Dict[str, Any]:
        """
        Reconstruct a thread with email content.
        
        Args:
            thread_id: Thread ID
            include_content: Whether to include email content
            
        Returns:
            Dictionary with thread information and emails with content
        """
        # Get the thread information
        thread_info = self.get_thread(thread_id)
        
        if include_content:
            # Add email content
            for email_info in thread_info['emails']:
                email_id = email_info['id']
                email = self.db_manager.get_email(email_id)
                
                if email.format == 'html':
                    # Get HTML content
                    html_page = self.db_manager.get_html_page(email.html_id) if email.html_id else None
                    if html_page:
                        with open(html_page.storage_path, 'r', encoding='utf-8') as f:
                            email_info['content'] = f.read()
                            email_info['content_type'] = 'html'
                else:
                    # Get text content
                    body = self.db_manager.get_body(email.body_id) if email.body_id else None
                    if body:
                        with open(body.storage_path, 'r', encoding='utf-8') as f:
                            email_info['content'] = f.read()
                            email_info['content_type'] = 'text'
        
        return thread_info
    
    def search_threads(self, query: Dict[str, Any], limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]:
        """
        Search for threads based on criteria.
        
        Args:
            query: Search criteria
            limit: Maximum number of results
            offset: Offset for pagination
            
        Returns:
            List of thread information dictionaries
        """
        # Search for threads
        threads = self.db_manager.search_threads(query, limit, offset)
        
        # Build thread information
        thread_infos = []
        for thread in threads:
            thread_info = {
                'id': thread.id,
                'subject': thread.subject,
                'date_started': thread.date_started,
                'last_date': thread.last_date,
                'priority': thread.priority,
                'email_count': self.db_manager.get_thread_email_count(thread.id)
            }
            thread_infos.append(thread_info)
        
        return thread_infos
    
    def get_thread_attachments(self, thread_id: str) -> List[Dict[str, Any]]:
        """
        Get all attachments in a thread.
        
        Args:
            thread_id: Thread ID
            
        Returns:
            List of attachment information dictionaries
        """
        # Get the emails in the thread
        emails = self.db_manager.get_emails_by_thread(thread_id)
        
        # Get all attachments
        all_attachments = []
        for email in emails:
            attachments = self.db_manager.get_email_attachments(email.id)
            for attachment in attachments:
                all_attachments.append({
                    'id': attachment.id,
                    'filename': attachment.filename,
                    'content_type': attachment.content_type,
                    'size': attachment.size,
                    'email_id': email.id,
                    'email_subject': email.subject,
                    'email_date': email.date_sent,
                    'email_from': email.from_address
                })
        
        return all_attachments
    
    def export_thread(self, thread_id: str, export_format: str = 'json', 
                     export_path: Optional[str] = None) -> str:
        """
        Export a thread to a file.
        
        Args:
            thread_id: Thread ID
            export_format: Export format ('json' or 'html')
            export_path: Optional export path
            
        Returns:
            Path to the exported file
        """
        # Get the thread with content
        thread_info = self.reconstruct_thread(thread_id)
        
        # Create the export path if not provided
        if not export_path:
            export_dir = Path(self.config['storage']['threads_dir'])
            export_path = str(export_dir / f"thread_{thread_id}.{export_format}")
        
        # Export based on format
        if export_format == 'json':
            with open(export_path, 'w', encoding='utf-8') as f:
                json.dump(thread_info, f, indent=2, default=str)
        elif export_format == 'html':
            # Create HTML representation of the thread
            html_content = self.thread_to_html(thread_info)
            with open(export_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
        else:
            raise ValueError(f"Unsupported export format: {export_format}")
        
        return export_path
    
    def thread_to_html(self, thread_info: Dict[str, Any]) -> str:
        """
        Convert thread information to HTML.
        
        Args:
            thread_info: Thread information
            
        Returns:
            HTML representation of the thread
        """
        # Create HTML header
        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{thread_info['subject']}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .thread-info {{ background-color: #f0f0f0; padding: 10px; margin-bottom: 20px; }}
        .email {{ border: 1px solid #ddd; margin-bottom: 20px; padding: 10px; }}
        .email-header {{ background-color: #f9f9f9; padding: 10px; margin-bottom: 10px; }}
        .email-content {{ padding: 10px; }}
        .attachment {{ background-color: #eaf2ff; padding: 5px; margin: 5px; display: inline-block; }}
    </style>
</head>
<body>
    <div class="thread-info">
        <h1>{thread_info['subject']}</h1>
        <p>Started: {thread_info['date_started']}</p>
        <p>Last updated: {thread_info['last_date']}</p>
        <p>Priority: {thread_info['priority']}</p>
        <p>Categories: {', '.join(cat['name'] for cat in thread_info['categories'])}</p>
    </div>
"""
        
        # Add emails
        for email in thread_info['emails']:
            html += f"""
    <div class="email">
        <div class="email-header">
            <p><strong>From:</strong> {email['from']}</p>
            <p><strong>To:</strong> {', '.join(email['to'])}</p>
"""
            
            if email['cc']:
                html += f"""            <p><strong>Cc:</strong> {', '.join(email['cc'])}</p>
"""
            
            html += f"""            <p><strong>Subject:</strong> {email['subject']}</p>
            <p><strong>Date:</strong> {email['date_sent']}</p>
"""
            
            if email['attachments']:
                html += f"""            <p><strong>Attachments:</strong></p>
            <div>
"""
                for attachment in email['attachments']:
                    html += f"""                <div class="attachment">{attachment['filename']} ({attachment['size']} bytes)</div>
"""
                html += f"""            </div>
"""
            
            html += f"""        </div>
        <div class="email-content">
"""
            
            if 'content' in email:
                if email.get('content_type') == 'html':
                    html += f"""            <iframe srcdoc="{email['content'].replace('"', '&quot;')}" width="100%" height="500px" frameborder="0"></iframe>
"""
                else:
                    html += f"""            <pre>{email['content']}</pre>
"""
            
            html += f"""        </div>
    </div>
"""
        
        # Close HTML
        html += """</body>
</html>"""
        
        return html
    
    def merge_threads(self, thread_ids: List[str]) -> str:
        """
        Merge multiple threads into a single thread.
        
        Args:
            thread_ids: List of thread IDs to merge
            
        Returns:
            ID of the merged thread
        """
        if not thread_ids or len(thread_ids) < 2:
            raise ValueError("At least two thread IDs are required for merging")
        
        # Get the threads
        threads = [self.db_manager.get_thread(thread_id) for thread_id in thread_ids]
        if any(thread is None for thread in threads):
            raise ValueError("One or more threads not found")
        
        # Use the first thread as the base
        base_thread = threads[0]
        
        # Get all emails from all threads
        all_emails = []
        for thread_id in thread_ids:
            emails = self.db_manager.get_emails_by_thread(thread_id)
            all_emails.extend(emails)
        
        # Update all emails to point to the base thread
        for email in all_emails:
            if email.thread_id != base_thread.id:
                self.db_manager.update_email_thread(email.id, base_thread.id)
        
        # Update the base thread's last_date
        last_date = max(email.date_sent for email in all_emails)
        self.db_manager.update_thread_last_date(base_thread.id, last_date)
        
        # Merge categories
        for thread in threads[1:]:
            categories = self.db_manager.get_thread_categories(thread.id)
            for category in categories:
                self.db_manager.add_thread_category(base_thread.id, category.id)
        
        # Merge rules
        for thread in threads[1:]:
            rules = self.db_manager.get_thread_rules(thread.id)
            for rule in rules:
                self.db_manager.add_thread_rule(base_thread.id, rule.id)
        
        # Delete the other threads
        for thread in threads[1:]:
            self.db_manager.delete_thread(thread.id)
        
        return base_thread.id

# DATABASE_MANAGER.PY
"""
Database Manager module for the Email Organization Application.
This module provides an interface for interacting with the database.
"""

import os
import datetime
import json
from typing import List, Dict, Any, Optional, Tuple, Union
from sqlalchemy import create_engine, func, or_, and_
from sqlalchemy.orm import sessionmaker, scoped_session
from sqlalchemy.sql import text

from app.models.database_models import (
    Base, User, EmailAccount, Contact, Domain, Email, Thread,
    Attachment, HtmlObject, Disclaimer, HtmlPage, Body,
    Category, Rule, Keyword, email_to_category, thread_to_category,
    contact_to_category, domain_to_category, email_to_rule,
    thread_to_rule, domain_to_rule, email_to_attachment,
    email_read_by, html_page_to_html_object, html_page_to_disclaimer,
    body_to_disclaimer, email_to_disclaimer
)
from app.utils.utils import get_config, encrypt_credentials

class DatabaseManager:
    """
    Provides an interface for interacting with the database.
    """
    
    def __init__(self):
        """Initialize the DatabaseManager."""
        self.config = get_config()
        
        # Create the database engine
        self.engine = create_engine(self.config['database']['connection_string'])
        
        # Create a session factory
        self.Session = scoped_session(sessionmaker(bind=self.engine))
    
    def init_db(self):
        """Initialize the database schema."""
        Base.metadata.create_all(self.engine)
    
    def get_session(self):
        """Get a database session."""
        return self.Session()
    
    def close_session(self, session):
        """Close a database session."""
        session.close()
    
    # User methods
    
    def add_user(self, user: User) -> str:
        """
        Add a user to the database.
        
        Args:
            user: User object
            
        Returns:
            User ID
        """
        session = self.get_session()
        try:
            session.add(user)
            session.commit()
            return user.id
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def get_user(self, user_id: str) -> Optional[User]:
        """
        Get a user by ID.
        
        Args:
            user_id: User ID
            
        Returns:
            User object or None
        """
        session = self.get_session()
        try:
            return session.query(User).filter(User.id == user_id).first()
        finally:
            self.close_session(session)
    
    def get_user_by_username(self, username: str) -> Optional[User]:
        """
        Get a user by username.
        
        Args:
            username: Username
            
        Returns:
            User object or None
        """
        session = self.get_session()
        try:
            return session.query(User).filter(User.username == username).first()
        finally:
            self.close_session(session)
    
    def get_user_by_email(self, email: str) -> Optional[User]:
        """
        Get a user by email.
        
        Args:
            email: Email address
            
        Returns:
            User object or None
        """
        session = self.get_session()
        try:
            return session.query(User).filter(User.email == email).first()
        finally:
            self.close_session(session)
    
    def update_user(self, user_id: str, data: Dict[str, Any]) -> bool:
        """
        Update a user.
        
        Args:
            user_id: User ID
            data: Dictionary of fields to update
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            user = session.query(User).filter(User.id == user_id).first()
            if not user:
                return False
            
            for key, value in data.items():
                if hasattr(user, key):
                    setattr(user, key, value)
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def delete_user(self, user_id: str) -> bool:
        """
        Delete a user.
        
        Args:
            user_id: User ID
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            user = session.query(User).filter(User.id == user_id).first()
            if not user:
                return False
            
            session.delete(user)
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    # Email Account methods
    
    def add_email_account(self, account: EmailAccount) -> str:
        """
        Add an email account to the database.
        
        Args:
            account: EmailAccount object
            
        Returns:
            Account ID
        """
        session = self.get_session()
        try:
            session.add(account)
            session.commit()
            return account.id
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def get_email_account(self, account_id: str) -> Optional[EmailAccount]:
        """
        Get an email account by ID.
        
        Args:
            account_id: Account ID
            
        Returns:
            EmailAccount object or None
        """
        session = self.get_session()
        try:
            return session.query(EmailAccount).filter(EmailAccount.id == account_id).first()
        finally:
            self.close_session(session)
    
    def get_user_email_accounts(self, user_id: str) -> List[EmailAccount]:
        """
        Get all email accounts for a user.
        
        Args:
            user_id: User ID
            
        Returns:
            List of EmailAccount objects
        """
        session = self.get_session()
        try:
            return session.query(EmailAccount).filter(EmailAccount.user_id == user_id).all()
        finally:
            self.close_session(session)
    
    def get_active_email_accounts(self) -> List[EmailAccount]:
        """
        Get all active email accounts.
        
        Returns:
            List of active EmailAccount objects
        """
        session = self.get_session()
        try:
            return session.query(EmailAccount).filter(EmailAccount.is_active == True).all()
        finally:
            self.close_session(session)
    
    def update_email_account(self, account_id: str, data: Dict[str, Any]) -> bool:
        """
        Update an email account.
        
        Args:
            account_id: Account ID
            data: Dictionary of fields to update
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            account = session.query(EmailAccount).filter(EmailAccount.id == account_id).first()
            if not account:
                return False
            
            for key, value in data.items():
                if hasattr(account, key):
                    setattr(account, key, value)
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def update_email_account_credentials(self, account_id: str, credentials: Dict[str, str]) -> bool:
        """
        Update an email account's credentials.
        
        Args:
            account_id: Account ID
            credentials: Dictionary of credentials
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            account = session.query(EmailAccount).filter(EmailAccount.id == account_id).first()
            if not account:
                return False
            
            # Encrypt the credentials
            encrypted_credentials = encrypt_credentials(credentials)
            account.encrypted_credentials = encrypted_credentials
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def update_email_account_last_sync(self, account_id: str, last_sync: datetime.datetime) -> bool:
        """
        Update an email account's last sync time.
        
        Args:
            account_id: Account ID
            last_sync: Last sync time
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            account = session.query(EmailAccount).filter(EmailAccount.id == account_id).first()
            if not account:
                return False
            
            account.last_sync = last_sync
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def delete_email_account(self, account_id: str) -> bool:
        """
        Delete an email account.
        
        Args:
            account_id: Account ID
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            account = session.query(EmailAccount).filter(EmailAccount.id == account_id).first()
            if not account:
                return False
            
            session.delete(account)
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)

    # Email methods
    
    def add_email(self, email: Email) -> str:
        """
        Add an email to the database.
        
        Args:
            email: Email object
            
        Returns:
            Email ID
        """
        session = self.get_session()
        try:
            session.add(email)
            session.commit()
            return email.id
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def get_email(self, email_id: str) -> Optional[Email]:
        """
        Get an email by ID.
        
        Args:
            email_id: Email ID
            
        Returns:
            Email object or None
        """
        session = self.get_session()
        try:
            return session.query(Email).filter(Email.id == email_id).first()
        finally:
            self.close_session(session)
    
    def get_email_by_original_id(self, original_id: str) -> Optional[Email]:
        """
        Get an email by original ID.
        
        Args:
            original_id: Original email ID
            
        Returns:
            Email object or None
        """
        session = self.get_session()
        try:
            return session.query(Email).filter(Email.original_id == original_id).first()
        finally:
            self.close_session(session)
    
    def get_email_by_details(self, from_address: str, subject: str, date: datetime.datetime) -> Optional[Email]:
        """
        Get an email by sender, subject, and date.
        
        Args:
            from_address: Sender address
            subject: Email subject
            date: Email date
            
        Returns:
            Email object or None
        """
        session = self.get_session()
        try:
            # Allow for a small time difference (1 minute)
            min_date = date - datetime.timedelta(minutes=1)
            max_date = date + datetime.timedelta(minutes=1)
            
            return session.query(Email).filter(
                Email.from_address == from_address,
                Email.subject == subject,
                Email.date_sent >= min_date,
                Email.date_sent <= max_date
            ).first()
        finally:
            self.close_session(session)
    
    def get_emails_by_thread(self, thread_id: str) -> List[Email]:
        """
        Get all emails in a thread.
        
        Args:
            thread_id: Thread ID
            
        Returns:
            List of Email objects
        """
        session = self.get_session()
        try:
            return session.query(Email).filter(Email.thread_id == thread_id).all()
        finally:
            self.close_session(session)
    
    def search_emails(self, query: Dict[str, Any], limit: int = 100, offset: int = 0) -> List[Email]:
        """
        Search for emails based on criteria.
        
        Args:
            query: Search criteria
            limit: Maximum number of results
            offset: Offset for pagination
            
        Returns:
            List of Email objects
        """
        session = self.get_session()
        try:
            q = session.query(Email)
            
            # Apply filters
            if 'from' in query:
                q = q.filter(Email.from_address.ilike(f"%{query['from']}%"))
            
            if 'to' in query:
                q = q.filter(Email.to_addresses.ilike(f"%{query['to']}%"))
            
            if 'subject' in query:
                q = q.filter(Email.subject.ilike(f"%{query['subject']}%"))
            
            if 'start_date' in query:
                q = q.filter(Email.date_sent >= query['start_date'])
            
            if 'end_date' in query:
                q = q.filter(Email.date_sent <= query['end_date'])
            
            if 'category_id' in query:
                q = q.join(email_to_category).filter(email_to_category.c.category_id == query['category_id'])
            
            if 'thread_id' in query:
                q = q.filter(Email.thread_id == query['thread_id'])
            
            # Apply sorting
            if 'sort' in query:
                if query['sort'] == 'date_asc':
                    q = q.order_by(Email.date_sent.asc())
                elif query['sort'] == 'date_desc':
                    q = q.order_by(Email.date_sent.desc())
                elif query['sort'] == 'priority_asc':
                    q = q.order_by(Email.priority.asc())
                elif query['sort'] == 'priority_desc':
                    q = q.order_by(Email.priority.desc())
            else:
                # Default sort by date descending
                q = q.order_by(Email.date_sent.desc())
            
            # Apply pagination
            q = q.limit(limit).offset(offset)
            
            return q.all()
        finally:
            self.close_session(session)
    
    def update_email(self, email_id: str, data: Dict[str, Any]) -> bool:
        """
        Update an email.
        
        Args:
            email_id: Email ID
            data: Dictionary of fields to update
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            email = session.query(Email).filter(Email.id == email_id).first()
            if not email:
                return False
            
            for key, value in data.items():
                if hasattr(email, key):
                    setattr(email, key, value)
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def update_email_thread(self, email_id: str, thread_id: str) -> bool:
        """
        Update an email's thread.
        
        Args:
            email_id: Email ID
            thread_id: Thread ID
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            email = session.query(Email).filter(Email.id == email_id).first()
            if not email:
                return False
            
            email.thread_id = thread_id
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def update_email_priority(self, email_id: str, priority: int) -> bool:
        """
        Update an email's priority.
        
        Args:
            email_id: Email ID
            priority: Priority value
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            email = session.query(Email).filter(Email.id == email_id).first()
            if not email:
                return False
            
            email.priority = priority
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def delete_email(self, email_id: str) -> bool:
        """
        Delete an email.
        
        Args:
            email_id: Email ID
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            email = session.query(Email).filter(Email.id == email_id).first()
            if not email:
                return False
            
            session.delete(email)
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    # Thread methods
    
    def add_thread(self, thread: Thread) -> str:
        """
        Add a thread to the database.
        
        Args:
            thread: Thread object
            
        Returns:
            Thread ID
        """
        session = self.get_session()
        try:
            session.add(thread)
            session.commit()
            return thread.id
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def get_thread(self, thread_id: str) -> Optional[Thread]:
        """
        Get a thread by ID.
        
        Args:
            thread_id: Thread ID
            
        Returns:
            Thread object or None
        """
        session = self.get_session()
        try:
            return session.query(Thread).filter(Thread.id == thread_id).first()
        finally:
            self.close_session(session)
    
    def get_thread_by_subject(self, subject: str) -> Optional[Thread]:
        """
        Get a thread by subject.
        
        Args:
            subject: Thread subject
            
        Returns:
            Thread object or None
        """
        session = self.get_session()
        try:
            return session.query(Thread).filter(Thread.subject == subject).first()
        finally:
            self.close_session(session)
    
    def get_thread_email_count(self, thread_id: str) -> int:
        """
        Get the number of emails in a thread.
        
        Args:
            thread_id: Thread ID
            
        Returns:
            Number of emails
        """
        session = self.get_session()
        try:
            return session.query(Email).filter(Email.thread_id == thread_id).count()
        finally:
            self.close_session(session)
    
    def search_threads(self, query: Dict[str, Any], limit: int = 100, offset: int = 0) -> List[Thread]:
        """
        Search for threads based on criteria.
        
        Args:
            query: Search criteria
            limit: Maximum number of results
            offset: Offset for pagination
            
        Returns:
            List of Thread objects
        """
        session = self.get_session()
        try:
            q = session.query(Thread)
            
            # Apply filters
            if 'subject' in query:
                q = q.filter(Thread.subject.ilike(f"%{query['subject']}%"))
            
            if 'start_date' in query:
                q = q.filter(Thread.last_date >= query['start_date'])
            
            if 'end_date' in query:
                q = q.filter(Thread.date_started <= query['end_date'])
            
            if 'category_id' in query:
                q = q.join(thread_to_category).filter(thread_to_category.c.category_id == query['category_id'])
            
            # Apply sorting
            if 'sort' in query:
                if query['sort'] == 'date_asc':
                    q = q.order_by(Thread.last_date.asc())
                elif query['sort'] == 'date_desc':
                    q = q.order_by(Thread.last_date.desc())
                elif query['sort'] == 'priority_asc':
                    q = q.order_by(Thread.priority.asc())
                elif query['sort'] == 'priority_desc':
                    q = q.order_by(Thread.priority.desc())
            else:
                # Default sort by date descending
                q = q.order_by(Thread.last_date.desc())
            
            # Apply pagination
            q = q.limit(limit).offset(offset)
            
            return q.all()
        finally:
            self.close_session(session)
    
    def update_thread(self, thread_id: str, data: Dict[str, Any]) -> bool:
        """
        Update a thread.
        
        Args:
            thread_id: Thread ID
            data: Dictionary of fields to update
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            thread = session.query(Thread).filter(Thread.id == thread_id).first()
            if not thread:
                return False
            
            for key, value in data.items():
                if hasattr(thread, key):
                    setattr(thread, key, value)
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def update_thread_last_date(self, thread_id: str, last_date: datetime.datetime) -> bool:
        """
        Update a thread's last date.
        
        Args:
            thread_id: Thread ID
            last_date: Last date
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            thread = session.query(Thread).filter(Thread.id == thread_id).first()
            if not thread:
                return False
            
            thread.last_date = last_date
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def update_thread_priority(self, thread_id: str, priority: int) -> bool:
        """
        Update a thread's priority.
        
        Args:
            thread_id: Thread ID
            priority: Priority value
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            thread = session.query(Thread).filter(Thread.id == thread_id).first()
            if not thread:
                return False
            
            thread.priority = priority
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def delete_thread(self, thread_id: str) -> bool:
        """
        Delete a thread.
        
        Args:
            thread_id: Thread ID
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            thread = session.query(Thread).filter(Thread.id == thread_id).first()
            if not thread:
                return False
            
            session.delete(thread)
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)

    # Attachment methods
    
    def add_attachment(self, attachment: Attachment) -> str:
        """
        Add an attachment to the database.
        
        Args:
            attachment: Attachment object
            
        Returns:
            Attachment ID
        """
        session = self.get_session()
        try:
            session.add(attachment)
            session.commit()
            return attachment.id
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def get_attachment(self, attachment_id: str) -> Optional[Attachment]:
        """
        Get an attachment by ID.
        
        Args:
            attachment_id: Attachment ID
            
        Returns:
            Attachment object or None
        """
        session = self.get_session()
        try:
            return session.query(Attachment).filter(Attachment.id == attachment_id).first()
        finally:
            self.close_session(session)
    
    def get_attachment_by_hash(self, hash: str) -> Optional[Attachment]:
        """
        Get an attachment by hash.
        
        Args:
            hash: Attachment hash
            
        Returns:
            Attachment object or None
        """
        session = self.get_session()
        try:
            return session.query(Attachment).filter(Attachment.hash == hash).first()
        finally:
            self.close_session(session)
    
    def get_email_attachments(self, email_id: str) -> List[Attachment]:
        """
        Get all attachments for an email.
        
        Args:
            email_id: Email ID
            
        Returns:
            List of Attachment objects
        """
        session = self.get_session()
        try:
            return session.query(Attachment).join(email_to_attachment).filter(
                email_to_attachment.c.email_id == email_id
            ).all()
        finally:
            self.close_session(session)
    
    def add_email_attachment(self, email_id: str, attachment_id: str) -> bool:
        """
        Associate an attachment with an email.
        
        Args:
            email_id: Email ID
            attachment_id: Attachment ID
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            # Check if the association already exists
            exists = session.query(email_to_attachment).filter(
                email_to_attachment.c.email_id == email_id,
                email_to_attachment.c.attachment_id == attachment_id
            ).first() is not None
            
            if exists:
                return True
            
            # Add the association
            session.execute(
                email_to_attachment.insert().values(
                    email_id=email_id,
                    attachment_id=attachment_id
                )
            )
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    # HTML Object methods
    
    def add_html_object(self, html_object: HtmlObject) -> str:
        """
        Add an HTML object to the database.
        
        Args:
            html_object: HtmlObject object
            
        Returns:
            HtmlObject ID
        """
        session = self.get_session()
        try:
            session.add(html_object)
            session.commit()
            return html_object.id
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def get_html_object(self, html_object_id: str) -> Optional[HtmlObject]:
        """
        Get an HTML object by ID.
        
        Args:
            html_object_id: HtmlObject ID
            
        Returns:
            HtmlObject object or None
        """
        session = self.get_session()
        try:
            return session.query(HtmlObject).filter(HtmlObject.id == html_object_id).first()
        finally:
            self.close_session(session)
    
    def get_html_object_by_hash(self, hash: str) -> Optional[HtmlObject]:
        """
        Get an HTML object by hash.
        
        Args:
            hash: HtmlObject hash
            
        Returns:
            HtmlObject object or None
        """
        session = self.get_session()
        try:
            return session.query(HtmlObject).filter(HtmlObject.hash == hash).first()
        finally:
            self.close_session(session)
    
    def get_html_page_html_objects(self, html_page_id: str) -> List[HtmlObject]:
        """
        Get all HTML objects for an HTML page.
        
        Args:
            html_page_id: HtmlPage ID
            
        Returns:
            List of HtmlObject objects
        """
        session = self.get_session()
        try:
            return session.query(HtmlObject).join(html_page_to_html_object).filter(
                html_page_to_html_object.c.html_page_id == html_page_id
            ).all()
        finally:
            self.close_session(session)
    
    def add_html_page_html_object(self, html_page_id: str, html_object_id: str) -> bool:
        """
        Associate an HTML object with an HTML page.
        
        Args:
            html_page_id: HtmlPage ID
            html_object_id: HtmlObject ID
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            # Check if the association already exists
            exists = session.query(html_page_to_html_object).filter(
                html_page_to_html_object.c.html_page_id == html_page_id,
                html_page_to_html_object.c.html_object_id == html_object_id
            ).first() is not None
            
            if exists:
                return True
            
            # Add the association
            session.execute(
                html_page_to_html_object.insert().values(
                    html_page_id=html_page_id,
                    html_object_id=html_object_id
                )
            )
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    # Disclaimer methods
    
    def add_disclaimer(self, disclaimer: Disclaimer) -> str:
        """
        Add a disclaimer to the database.
        
        Args:
            disclaimer: Disclaimer object
            
        Returns:
            Disclaimer ID
        """
        session = self.get_session()
        try:
            session.add(disclaimer)
            session.commit()
            return disclaimer.id
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def get_disclaimer(self, disclaimer_id: str) -> Optional[Disclaimer]:
        """
        Get a disclaimer by ID.
        
        Args:
            disclaimer_id: Disclaimer ID
            
        Returns:
            Disclaimer object or None
        """
        session = self.get_session()
        try:
            return session.query(Disclaimer).filter(Disclaimer.id == disclaimer_id).first()
        finally:
            self.close_session(session)
    
    def get_disclaimer_by_hash(self, hash: str) -> Optional[Disclaimer]:
        """
        Get a disclaimer by hash.
        
        Args:
            hash: Disclaimer hash
            
        Returns:
            Disclaimer object or None
        """
        session = self.get_session()
        try:
            return session.query(Disclaimer).filter(Disclaimer.hash == hash).first()
        finally:
            self.close_session(session)
    
    def get_email_disclaimers(self, email_id: str) -> List[Disclaimer]:
        """
        Get all disclaimers for an email.
        
        Args:
            email_id: Email ID
            
        Returns:
            List of Disclaimer objects
        """
        session = self.get_session()
        try:
            return session.query(Disclaimer).join(email_to_disclaimer).filter(
                email_to_disclaimer.c.email_id == email_id
            ).all()
        finally:
            self.close_session(session)
    
    def add_email_disclaimer(self, email_id: str, disclaimer_id: str) -> bool:
        """
        Associate a disclaimer with an email.
        
        Args:
            email_id: Email ID
            disclaimer_id: Disclaimer ID
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            # Check if the association already exists
            exists = session.query(email_to_disclaimer).filter(
                email_to_disclaimer.c.email_id == email_id,
                email_to_disclaimer.c.disclaimer_id == disclaimer_id
            ).first() is not None
            
            if exists:
                return True
            
            # Add the association
            session.execute(
                email_to_disclaimer.insert().values(
                    email_id=email_id,
                    disclaimer_id=disclaimer_id
                )
            )
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def add_html_page_disclaimer(self, html_page_id: str, disclaimer_id: str) -> bool:
        """
        Associate a disclaimer with an HTML page.
        
        Args:
            html_page_id: HtmlPage ID
            disclaimer_id: Disclaimer ID
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            # Check if the association already exists
            exists = session.query(html_page_to_disclaimer).filter(
                html_page_to_disclaimer.c.html_page_id == html_page_id,
                html_page_to_disclaimer.c.disclaimer_id == disclaimer_id
            ).first() is not None
            
            if exists:
                return True
            
            # Add the association
            session.execute(
                html_page_to_disclaimer.insert().values(
                    html_page_id=html_page_id,
                    disclaimer_id=disclaimer_id
                )
            )
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)
    
    def add_body_disclaimer(self, body_id: str, disclaimer_id: str) -> bool:
        """
        Associate a disclaimer with a body.
        
        Args:
            body_id: Body ID
            disclaimer_id: Disclaimer ID
            
        Returns:
            True if successful, False otherwise
        """
        session = self.get_session()
        try:
            # Check if the association already exists
            exists = session.query(body_to_disclaimer).filter(
                body_to_disclaimer.c.body_id == body_id,
                body_to_disclaimer.c.disclaimer_id == disclaimer_id
            ).first() is not None
            
            if exists:
                return True
            
            # Add the association
            session.execute(
                body_to_disclaimer.insert().values(
                    body_id=body_id,
                    disclaimer_id=disclaimer_id
                )
            )
            
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            raise e
        finally:
            self.close_session(session)

# API.PY
# This module provides the API endpoints for the web frontend

import os
import json
import logging
from typing import Dict, List, Any, Optional
from datetime import datetime
from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.utils import secure_filename
import jwt
from functools import wraps

from app.database.database_manager import DatabaseManager
from app.models.database_models import User, EmailAccount, Email, Thread, Attachment, HtmlObject, Disclaimer
from app.email_processing.email_processor import EmailProcessor
from app.email_retriever import EmailRetriever
from app.thread_manager import ThreadManager

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('api.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Load configuration
with open('config.json', 'r') as f:
    config = json.load(f)

app.config['SECRET_KEY'] = config['api']['secret_key']
app.config['UPLOAD_FOLDER'] = config['paths']['upload_folder']
app.config['MAX_CONTENT_LENGTH'] = config['api']['max_content_length']

# Initialize database manager
db_manager = DatabaseManager(config['database']['connection_string'])

# Initialize email processor
email_processor = EmailProcessor(
    db_manager=db_manager,
    attachment_folder=config['paths']['attachment_folder'],
    html_object_folder=config['paths']['html_object_folder'],
    max_attachment_size=config['email']['max_attachment_size']
)

# Initialize email retriever
email_retriever = EmailRetriever(
    db_manager=db_manager,
    email_processor=email_processor
)

# Initialize thread manager
thread_manager = ThreadManager(
    db_manager=db_manager
)

# Authentication decorator
def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = None
        
        # Check if token is in the headers
        if 'Authorization' in request.headers:
            auth_header = request.headers['Authorization']
            if auth_header.startswith('Bearer '):
                token = auth_header.split(' ')[1]
        
        if not token:
            return jsonify({'message': 'Token is missing'}), 401
        
        try:
            # Decode the token
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            current_user = db_manager.get_user(data['user_id'])
            
            if not current_user:
                return jsonify({'message': 'User not found'}), 401
                
        except jwt.ExpiredSignatureError:
            return jsonify({'message': 'Token has expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'message': 'Invalid token'}), 401
        
        # Pass the current user to the route
        return f(current_user, *args, **kwargs)
    
    return decorated

# Routes

@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({'status': 'ok'})

# Authentication routes

@app.route('/api/auth/register', methods=['POST'])
def register():
    """Register a new user"""
    data = request.get_json()
    
    # Validate required fields
    required_fields = ['username', 'email', 'password']
    for field in required_fields:
        if field not in data:
            return jsonify({'message': f'Missing required field: {field}'}), 400
    
    # Check if user already exists
    if db_manager.get_user_by_username(data['username']):
        return jsonify({'message': 'Username already exists'}), 400
    
    if db_manager.get_user_by_email(data['email']):
        return jsonify({'message': 'Email already exists'}), 400
    
    # Create new user
    user = User(
        username=data['username'],
        email=data['email'],
        password_hash=generate_password_hash(data['password']),
        first_name=data.get('first_name', ''),
        last_name=data.get('last_name', '')
    )
    
    user_id = db_manager.add_user(user)
    
    return jsonify({
        'message': 'User registered successfully',
        'user_id': user_id
    }), 201

@app.route('/api/auth/login', methods=['POST'])
def login():
    """Login a user"""
    data = request.get_json()
    
    # Validate required fields
    if 'username' not in data or 'password' not in data:
        return jsonify({'message': 'Missing username or password'}), 400
    
    # Get user by username
    user = db_manager.get_user_by_username(data['username'])
    
    if not user:
        return jsonify({'message': 'Invalid username or password'}), 401
    
    # Check password
    if not check_password_hash(user.password_hash, data['password']):
        return jsonify({'message': 'Invalid username or password'}), 401
    
    # Generate token
    token = jwt.encode({
        'user_id': user.id,
        'exp': datetime.utcnow() + config['api']['token_expiry']
    }, app.config['SECRET_KEY'], algorithm='HS256')
    
    return jsonify({
        'message': 'Login successful',
        'token': token,
        'user': {
            'id': user.id,
            'username': user.username,
            'email': user.email,
            'first_name': user.first_name,
            'last_name': user.last_name
        }
    }), 200

# User routes

@app.route('/api/users/me', methods=['GET'])
@token_required
def get_current_user(current_user):
    """Get current user information"""
    return jsonify({
        'id': current_user.id,
        'username': current_user.username,
        'email': current_user.email,
        'first_name': current_user.first_name,
        'last_name': current_user.last_name
    }), 200

@app.route('/api/users/me', methods=['PUT'])
@token_required
def update_current_user(current_user):
    """Update current user information"""
    data = request.get_json()
    
    # Update user fields
    if 'first_name' in data:
        current_user.first_name = data['first_name']
    
    if 'last_name' in data:
        current_user.last_name = data['last_name']
    
    if 'email' in data:
        # Check if email already exists
        existing_user = db_manager.get_user_by_email(data['email'])
        if existing_user and existing_user.id != current_user.id:
            return jsonify({'message': 'Email already exists'}), 400
        
        current_user.email = data['email']
    
    if 'password' in data:
        current_user.password_hash = generate_password_hash(data['password'])
    
    # Update user in database
    db_manager.update_user(current_user)
    
    return jsonify({
        'message': 'User updated successfully',
        'user': {
            'id': current_user.id,
            'username': current_user.username,
            'email': current_user.email,
            'first_name': current_user.first_name,
            'last_name': current_user.last_name
        }
    }), 200

# Email account routes

@app.route('/api/email-accounts', methods=['GET'])
@token_required
def get_email_accounts(current_user):
    """Get all email accounts for the current user"""
    accounts = db_manager.get_user_email_accounts(current_user.id)
    
    return jsonify({
        'accounts': [{
            'id': account.id,
            'name': account.name,
            'email': account.email,
            'provider': account.provider,
            'is_active': account.is_active
        } for account in accounts]
    }), 200

@app.route('/api/email-accounts', methods=['POST'])
@token_required
def add_email_account(current_user):
    """Add a new email account for the current user"""
    data = request.get_json()
    
    # Validate required fields
    required_fields = ['name', 'email', 'provider', 'credentials']
    for field in required_fields:
        if field not in data:
            return jsonify({'message': f'Missing required field: {field}'}), 400
    
    # Create new email account
    account = EmailAccount(
        user_id=current_user.id,
        name=data['name'],
        email=data['email'],
        provider=data['provider'],
        credentials=json.dumps(data['credentials']),
        is_active=data.get('is_active', True)
    )
    
    account_id = db_manager.add_email_account(account)
    
    return jsonify({
        'message': 'Email account added successfully',
        'account_id': account_id
    }), 201

@app.route('/api/email-accounts/<account_id>', methods=['GET'])
@token_required
def get_email_account(current_user, account_id):
    """Get email account by ID"""
    account = db_manager.get_email_account(account_id)
    
    if not account:
        return jsonify({'message': 'Email account not found'}), 404
    
    # Check if account belongs to current user
    if account.user_id != current_user.id:
        return jsonify({'message': 'Unauthorized'}), 403
    
    return jsonify({
        'id': account.id,
        'name': account.name,
        'email': account.email,
        'provider': account.provider,
        'is_active': account.is_active
    }), 200

@app.route('/api/email-accounts/<account_id>', methods=['PUT'])
@token_required
def update_email_account(current_user, account_id):
    """Update email account by ID"""
    account = db_manager.get_email_account(account_id)
    
    if not account:
        return jsonify({'message': 'Email account not found'}), 404
    
    # Check if account belongs to current user
    if account.user_id != current_user.id:
        return jsonify({'message': 'Unauthorized'}), 403
    
    data = request.get_json()
    
    # Update account fields
    if 'name' in data:
        account.name = data['name']
    
    if 'email' in data:
        account.email = data['email']
    
    if 'provider' in data:
        account.provider = data['provider']
    
    if 'credentials' in data:
        account.credentials = json.dumps(data['credentials'])
    
    if 'is_active' in data:
        account.is_active = data['is_active']
    
    # Update account in database
    db_manager.update_email_account(account)
    
    return jsonify({
        'message': 'Email account updated successfully',
        'account': {
            'id': account.id,
            'name': account.name,
            'email': account.email,
            'provider': account.provider,
            'is_active': account.is_active
        }
    }), 200

@app.route('/api/email-accounts/<account_id>', methods=['DELETE'])
@token_required
def delete_email_account(current_user, account_id):
    """Delete email account by ID"""
    account = db_manager.get_email_account(account_id)
    
    if not account:
        return jsonify({'message': 'Email account not found'}), 404
    
    # Check if account belongs to current user
    if account.user_id != current_user.id:
        return jsonify({'message': 'Unauthorized'}), 403
    
    # Delete account from database
    db_manager.delete_email_account(account_id)
    
    return jsonify({
        'message': 'Email account deleted successfully'
    }), 200

# Email routes

@app.route('/api/emails', methods=['GET'])
@token_required
def get_emails(current_user):
    """Get emails for the current user with optional filtering"""
    # Get query parameters
    account_id = request.args.get('account_id')
    thread_id = request.args.get('thread_id')
    from_address = request.args.get('from')
    to_address = request.args.get('to')
    subject = request.args.get('subject')
    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')
    has_attachments = request.args.get('has_attachments')
    
    # Convert date strings to datetime objects
    if start_date:
        start_date = datetime.fromisoformat(start_date)
    
    if end_date:
        end_date = datetime.fromisoformat(end_date)
    
    # Convert has_attachments to boolean
    if has_attachments:
        has_attachments = has_attachments.lower() == 'true'
    
    # Get user's email accounts
    user_accounts = db_manager.get_user_email_accounts(current_user.id)
    user_account_ids = [account.id for account in user_accounts]
    
    # If account_id is specified, check if it belongs to the user
    if account_id and account_id not in user_account_ids:
        return jsonify({'message': 'Unauthorized'}), 403
    
    # Build filters
    filters = {}
    
    if account_id:
        filters['account_id'] = account_id
    else:
        filters['account_id'] = user_account_ids
    
    if thread_id:
        filters['thread_id'] = thread_id
    
    if from_address:
        filters['from_address'] = from_address
    
    if to_address:
        filters['to_address'] = to_address
    
    if subject:
        filters['subject'] = subject
    
    if start_date:
        filters['start_date'] = start_date
    
    if end_date:
        filters['end_date'] = end_date
    
    if has_attachments is not None:
        filters['has_attachments'] = has_attachments
    
    # Get emails from database
    emails = db_manager.search_emails(filters)
    
    return jsonify({
        'emails': [{
            'id': email.id,
            'from_address': email.from_address,
            'to_addresses': json.loads(email.to_addresses),
            'subject': email.subject,
            'date_sent': email.date_sent.isoformat() if email.date_sent else None,
            'has_attachments': len(db_manager.get_email_attachments(email.id)) > 0,
            'thread_id': email.thread_id
        } for email in emails]
    }), 200

@app.route('/api/emails/<email_id>', methods=['GET'])
@token_required
def get_email(current_user, email_id):
    """Get email by ID"""
    email = db_manager.get_email(email_id)
    
    if not email:
        return jsonify({'message': 'Email not found'}), 404
    
    # Check if email belongs to current user
    account = db_manager.get_email_account(email.account_id)
    if not account or account.user_id != current_user.id:
        return jsonify({'message': 'Unauthorized'}), 403
    
    # Get email body
    body = db_manager.get_body(email.body_id) if email.body_id else None
    
    # Get email HTML
    html_page = db_manager.get_html_page(email.html_id) if email.html_id else None
    
    # Get email attachments
    attachments = db_manager.get_email_attachments(email.id)
    
    # Get email disclaimers
    disclaimers = db_manager.get_email_disclaimers(email.id)
    
    return jsonify({
        'id': email.id,
        'from_address': email.from_address,
        'to_addresses': json.loads(email.to_addresses),
        'subject': email.subject,
        'date_sent': email.date_sent.isoformat() if email.date_sent else None,
        'body': body.content if body else None,
        'html': html_page.content if html_page else None,
        'attachments': [{
            'id': attachment.id,
            'filename': attachment.filename,
            'mime_type': attachment.mime_type,
            'size': attachment.size
        } for attachment in attachments],
        'disclaimers': [{
            'id': disclaimer.id,
            'text': disclaimer.text
        } for disclaimer in disclaimers],
        'thread_id': email.thread_id
    }), 200

@app.route('/api/emails/<email_id>/attachments/<attachment_id>', methods=['GET'])
@token_required
def get_email_attachment(current_user, email_id, attachment_id):
    """Get email attachment by ID"""
    email = db_manager.get_email(email_id)
    
    if not email:
        return jsonify({'message': 'Email not found'}), 404
    
    # Check if email belongs to current user
    account = db_manager.get_email_account(email.account_id)
    if not account or account.user_id != current_user.id:
        return jsonify({'message': 'Unauthorized'}), 403
    
    # Get attachment
    attachment = db_manager.get_attachment(attachment_id)
    
    if not attachment:
        return jsonify({'message': 'Attachment not found'}), 404
    
    # Check if attachment belongs to email
    attachments = db_manager.get_email_attachments(email.id)
    if attachment not in attachments:
        return jsonify({'message': 'Attachment not found in email'}), 404
    
    # Get attachment file path
    file_path = os.path.join(config['paths']['attachment_folder'], attachment.filename)
    
    # Check if file exists
    if not os.path.exists(file_path):
        return jsonify({'message': 'Attachment file not found'}), 404
    
    # Send file
    return send_file(
        file_path,
        mimetype=attachment.mime_type,
        as_attachment=True,
        download_name=attachment.filename
    )

# Thread routes

@app.route('/api/threads', methods=['GET'])
@token_required
def get_threads(current_user):
    """Get threads for the current user with optional filtering"""
    # Get query parameters
    account_id = request.args.get('account_id')
    subject = request.args.get('subject')
    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')
    
    # Convert date strings to datetime objects
    if start_date:
        start_date = datetime.fromisoformat(start_date)
    
    if end_date:
        end_date = datetime.fromisoformat(end_date)
    
    # Get user's email accounts
    user_accounts = db_manager.get_user_email_accounts(current_user.id)
    user_account_ids = [account.id for account in user_accounts]
    
    # If account_id is specified, check if it belongs to the user
    if account_id and account_id not in user_account_ids:
        return jsonify({'message': 'Unauthorized'}), 403
    
    # Build filters
    filters = {}
    
    if account_id:
        filters['account_id'] = account_id
    else:
        filters['account_id'] = user_account_ids
    
    if subject:
        filters['subject'] = subject
    
    if start_date:
        filters['start_date'] = start_date
    
    if end_date:
        filters['end_date'] = end_date
    
    # Get threads from database
    threads = db_manager.search_threads(filters)
    
    return jsonify({
        'threads': [{
            'id': thread.id,
            'subject': thread.subject,
            'date_started': thread.date_started.isoformat() if thread.date_started else None,
            'last_date': thread.last_date.isoformat() if thread.last_date else None,
            'priority': thread.priority,
            'email_count': len(db_manager.get_thread_emails(thread.id))
        } for thread in threads]
    }), 200

@app.route('/api/threads/<thread_id>', methods=['GET'])
@token_required
def get_thread(current_user, thread_id):
    """Get thread by ID"""
    thread = db_manager.get_thread(thread_id)
    
    if not thread:
        return jsonify({'message': 'Thread not found'}), 404
    
    # Get thread emails
    emails = db_manager.get_thread_emails(thread_id)
    
    # Check if any email belongs to current user
    user_accounts = db_manager.get_user_email_accounts(current_user.id)
    user_account_ids = [account.id for account in user_accounts]
    
    if not any(email.account_id in user_account_ids for email in emails):
        return jsonify({'message': 'Unauthorized'}), 403
    
    return jsonify({
        'id': thread.id,
        'subject': thread.subject,
        'date_started': thread.date_started.isoformat() if thread.date_started else None,
        'last_date': thread.last_date.isoformat() if thread.last_date else None,
        'emails': [{
            'id': email.id,
            'from_address': email.from_address,
            'to_addresses': json.loads(email.to_addresses),
            'subject': email.subject,
            'date_sent': email.date_sent.isoformat() if email.date_sent else None,
            'has_attachments': len(db_manager.get_email_attachments(email.id)) > 0
        } for email in emails]
    }), 200

# Email retrieval routes

@app.route('/api/email-accounts/<account_id>/sync', methods=['POST'])
@token_required
def sync_email_account(current_user, account_id):
    """Sync emails for an email account"""
    account = db_manager.get_email_account(account_id)
    
    if not account:
        return jsonify({'message': 'Email account not found'}), 404
    
    # Check if account belongs to current user
    if account.user_id != current_user.id:
        return jsonify({'message': 'Unauthorized'}), 403
    
    # Get filters from request
    data = request.get_json() or {}
    filters = data.get('filters', {})
    
    # Sync emails
    try:
        email_ids = email_retriever.retrieve_emails(account_id, filters)
        
        return jsonify({
            'message': 'Email account synced successfully',
            'emails_retrieved': len(email_ids)
        }), 200
    except Exception as e:
        logger.error(f'Error syncing email account: {str(e)}')
        return jsonify({'message': f'Error syncing email account: {str(e)}'}), 500

# Main entry point
if __name__ == '__main__':
    app.run(debug=config['api']['debug'], host=config['api']['host'], port=config['api']['port'])

# FRONTEND
# This section contains the frontend web application code

# Structure:
# - src/
#   - components/
#     - Authentication/
#       - Login.js
#       - Register.js
#     - Dashboard/
#       - Dashboard.js
#       - Sidebar.js
#       - EmailList.js
#       - EmailView.js
#       - ThreadView.js
#     - EmailAccounts/
#       - AccountList.js
#       - AccountForm.js
#     - Common/
#       - Header.js
#       - Footer.js
#       - Loading.js
#       - ErrorMessage.js
#   - services/
#     - api.js
#     - auth.js
#   - utils/
#     - dateUtils.js
#     - formatUtils.js
#   - App.js
#   - index.js
#   - routes.js
# - public/
#   - index.html
#   - assets/

# package.json
"""
{
  "name": "email-org-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.10.5",
    "@emotion/styled": "^11.10.5",
    "@mui/icons-material": "^5.11.0",
    "@mui/material": "^5.11.0",
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.2.1",
    "date-fns": "^2.29.3",
    "jwt-decode": "^3.1.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.5.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
"""

# src/services/api.js
"""
import axios from 'axios';
import { getToken } from './auth';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';

// Create axios instance
const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor to add auth token
api.interceptors.request.use(
  (config) => {
    const token = getToken();
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Authentication API calls
export const register = (userData) => {
  return api.post('/auth/register', userData);
};

export const login = (credentials) => {
  return api.post('/auth/login', credentials);
};

// User API calls
export const getCurrentUser = () => {
  return api.get('/users/me');
};

export const updateCurrentUser = (userData) => {
  return api.put('/users/me', userData);
};

// Email account API calls
export const getEmailAccounts = () => {
  return api.get('/email-accounts');
};

export const addEmailAccount = (accountData) => {
  return api.post('/email-accounts', accountData);
};

export const getEmailAccount = (accountId) => {
  return api.get(`/email-accounts/${accountId}`);
};

export const updateEmailAccount = (accountId, accountData) => {
  return api.put(`/email-accounts/${accountId}`, accountData);
};

export const deleteEmailAccount = (accountId) => {
  return api.delete(`/email-accounts/${accountId}`);
};

export const syncEmailAccount = (accountId, filters = {}) => {
  return api.post(`/email-accounts/${accountId}/sync`, { filters });
};

// Email API calls
export const getEmails = (filters = {}) => {
  return api.get('/emails', { params: filters });
};

export const getEmail = (emailId) => {
  return api.get(`/emails/${emailId}`);
};

export const getEmailAttachment = (emailId, attachmentId) => {
  return api.get(`/emails/${emailId}/attachments/${attachmentId}`, {
    responseType: 'blob',
  });
};

// Thread API calls
export const getThreads = (filters = {}) => {
  return api.get('/threads', { params: filters });
};

export const getThread = (threadId) => {
  return api.get(`/threads/${threadId}`);
};

export default api;
"""

# src/services/auth.js
"""
import jwtDecode from 'jwt-decode';

const TOKEN_KEY = 'email_org_token';
const USER_KEY = 'email_org_user';

// Save token and user data to localStorage
export const setAuth = (token, user) => {
  localStorage.setItem(TOKEN_KEY, token);
  localStorage.setItem(USER_KEY, JSON.stringify(user));
};

// Remove token and user data from localStorage
export const clearAuth = () => {
  localStorage.removeItem(TOKEN_KEY);
  localStorage.removeItem(USER_KEY);
};

// Get token from localStorage
export const getToken = () => {
  return localStorage.getItem(TOKEN_KEY);
};

// Get user data from localStorage
export const getUser = () => {
  const userStr = localStorage.getItem(USER_KEY);
  return userStr ? JSON.parse(userStr) : null;
};

// Check if user is authenticated
export const isAuthenticated = () => {
  const token = getToken();
  if (!token) {
    return false;
  }

  try {
    const decoded = jwtDecode(token);
    const currentTime = Date.now() / 1000;
    
    // Check if token is expired
    if (decoded.exp < currentTime) {
      clearAuth();
      return false;
    }
    
    return true;
  } catch (error) {
    clearAuth();
    return false;
  }
};

// Update user data in localStorage
export const updateUser = (userData) => {
  const currentUser = getUser();
  if (currentUser) {
    const updatedUser = { ...currentUser, ...userData };
    localStorage.setItem(USER_KEY, JSON.stringify(updatedUser));
  }
};
"""

# src/utils/dateUtils.js
"""
import { format, parseISO, isValid } from 'date-fns';

// Format date to display format
export const formatDate = (dateString) => {
  if (!dateString) return '';
  
  const date = parseISO(dateString);
  if (!isValid(date)) return '';
  
  return format(date, 'MMM d, yyyy h:mm a');
};

// Format date to short format
export const formatShortDate = (dateString) => {
  if (!dateString) return '';
  
  const date = parseISO(dateString);
  if (!isValid(date)) return '';
  
  return format(date, 'MMM d, yyyy');
};

// Format date to time only
export const formatTime = (dateString) => {
  if (!dateString) return '';
  
  const date = parseISO(dateString);
  if (!isValid(date)) return '';
  
  return format(date, 'h:mm a');
};

// Get relative time (today, yesterday, etc.)
export const getRelativeTime = (dateString) => {
  if (!dateString) return '';
  
  const date = parseISO(dateString);
  if (!isValid(date)) return '';
  
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  
  if (date >= today) {
    return format(date, 'h:mm a');
  } else if (date >= yesterday) {
    return 'Yesterday';
  } else {
    return format(date, 'MMM d');
  }
};
"""

# src/utils/formatUtils.js
"""
// Format file size to human-readable format
export const formatFileSize = (bytes) => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

// Truncate text to specified length
export const truncateText = (text, maxLength = 100) => {
  if (!text) return '';
  
  if (text.length <= maxLength) return text;
  
  return text.substring(0, maxLength) + '...';
};

// Extract email address from string (e.g., "John Doe <john@example.com>")
export const extractEmailAddress = (emailString) => {
  if (!emailString) return '';
  
  const match = emailString.match(/<([^>]+)>/);
  if (match && match[1]) {
    return match[1];
  }
  
  return emailString.trim();
};

// Extract name from email string (e.g., "John Doe <john@example.com>")
export const extractName = (emailString) => {
  if (!emailString) return '';
  
  const match = emailString.match(/^([^<]+)</);
  if (match && match[1]) {
    return match[1].trim();
  }
  
  const emailMatch = emailString.match(/([^@]+)@/);
  if (emailMatch && emailMatch[1]) {
    return emailMatch[1];
  }
  
  return emailString.trim();
};

// Format email addresses for display
export const formatEmailAddresses = (addresses, maxAddresses = 3) => {
  if (!addresses || addresses.length === 0) return '';
  
  const formatted = addresses.slice(0, maxAddresses).map(extractName).join(', ');
  
  if (addresses.length > maxAddresses) {
    return `${formatted} and ${addresses.length - maxAddresses} more`;
  }
  
  return formatted;
};
"""

# src/components/Common/Header.js
"""
import React from 'react';
import { AppBar, Toolbar, Typography, Button, IconButton, Box } from '@mui/material';
import { Menu as MenuIcon, AccountCircle } from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { clearAuth, getUser } from '../../services/auth';

const Header = ({ toggleSidebar }) => {
  const navigate = useNavigate();
  const user = getUser();
  
  const handleLogout = () => {
    clearAuth();
    navigate('/login');
  };
  
  return (
    <AppBar position="fixed">
      <Toolbar>
        <IconButton
          color="inherit"
          aria-label="open drawer"
          edge="start"
          onClick={toggleSidebar}
          sx={{ mr: 2 }}
        >
          <MenuIcon />
        </IconButton>
        
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          Email Organizer
        </Typography>
        
        {user && (
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <Typography variant="body1" sx={{ mr: 2 }}>
              {user.username}
            </Typography>
            <IconButton
              color="inherit"
              aria-label="account"
              onClick={() => navigate('/profile')}
            >
              <AccountCircle />
            </IconButton>
            <Button color="inherit" onClick={handleLogout}>
              Logout
            </Button>
          </Box>
        )}
      </Toolbar>
    </AppBar>
  );
};

export default Header;
"""

# src/components/Common/Loading.js
"""
import React from 'react';
import { CircularProgress, Box, Typography } from '@mui/material';

const Loading = ({ message = 'Loading...' }) => {
  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100%',
        minHeight: '200px',
      }}
    >
      <CircularProgress />
      <Typography variant="body1" sx={{ mt: 2 }}>
        {message}
      </Typography>
    </Box>
  );
};

export default Loading;
"""

# src/components/Common/ErrorMessage.js
"""
import React from 'react';
import { Alert, Box } from '@mui/material';

const ErrorMessage = ({ message, onClose }) => {
  if (!message) return null;
  
  return (
    <Box sx={{ mb: 2 }}>
      <Alert severity="error" onClose={onClose}>
        {message}
      </Alert>
    </Box>
  );
};

export default ErrorMessage;
"""

# src/components/Authentication/Login.js
"""
import React, { useState } from 'react';
import {
  Container,
  Box,
  Typography,
  TextField,
  Button,
  Paper,
  Link,
} from '@mui/material';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import { login } from '../../services/api';
import { setAuth } from '../../services/auth';
import ErrorMessage from '../Common/ErrorMessage';

const Login = () => {
  const navigate = useNavigate();
  const [formData, setFormData] = useState({
    username: '',
    password: '',
  });
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);
    
    try {
      const response = await login(formData);
      setAuth(response.data.token, response.data.user);
      navigate('/dashboard');
    } catch (err) {
      setError(
        err.response?.data?.message || 'An error occurred during login'
      );
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <Container maxWidth="sm">
      <Box
        sx={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          mt: 8,
        }}
      >
        <Paper
          elevation={3}
          sx={{
            p: 4,
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
          }}
        >
          <Typography component="h1" variant="h5">
            Sign In
          </Typography>
          
          <ErrorMessage message={error} onClose={() => setError('')} />
          
          <Box component="form" onSubmit={handleSubmit} sx={{ mt: 1, width: '100%' }}>
            <TextField
              margin="normal"
              required
              fullWidth
              id="username"
              label="Username"
              name="username"
              autoComplete="username"
              autoFocus
              value={formData.username}
              onChange={handleChange}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type="password"
              id="password"
              autoComplete="current-password"
              value={formData.password}
              onChange={handleChange}
            />
            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{ mt: 3, mb: 2 }}
              disabled={loading}
            >
              {loading ? 'Signing In...' : 'Sign In'}
            </Button>
            <Box sx={{ textAlign: 'center' }}>
              <Link component={RouterLink} to="/register" variant="body2">
                {"Don't have an account? Sign Up"}
              </Link>
            </Box>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
};

export default Login;
"""

# src/components/Authentication/Register.js
"""
import React, { useState } from 'react';
import {
  Container,
  Box,
  Typography,
  TextField,
  Button,
  Paper,
  Link,
  Grid,
} from '@mui/material';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import { register } from '../../services/api';
import ErrorMessage from '../Common/ErrorMessage';

const Register = () => {
  const navigate = useNavigate();
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    firstName: '',
    lastName: '',
  });
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    
    // Validate form data
    if (formData.password !== formData.confirmPassword) {
      setError('Passwords do not match');
      return;
    }
    
    setLoading(true);
    
    try {
      const userData = {
        username: formData.username,
        email: formData.email,
        password: formData.password,
        first_name: formData.firstName,
        last_name: formData.lastName,
      };
      
      await register(userData);
      navigate('/login', { state: { message: 'Registration successful. Please log in.' } });
    } catch (err) {
      setError(
        err.response?.data?.message || 'An error occurred during registration'
      );
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <Container maxWidth="sm">
      <Box
        sx={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          mt: 8,
        }}
      >
        <Paper
          elevation={3}
          sx={{
            p: 4,
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
          }}
        >
          <Typography component="h1" variant="h5">
            Sign Up
          </Typography>
          
          <ErrorMessage message={error} onClose={() => setError('')} />
          
          <Box component="form" onSubmit={handleSubmit} sx={{ mt: 1, width: '100%' }}>
            <TextField
              margin="normal"
              required
              fullWidth
              id="username"
              label="Username"
              name="username"
              autoComplete="username"
              autoFocus
              value={formData.username}
              onChange={handleChange}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email Address"
              name="email"
              autoComplete="email"
              value={formData.email}
              onChange={handleChange}
            />
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6}>
                <TextField
                  margin="normal"
                  fullWidth
                  id="firstName"
                  label="First Name"
                  name="firstName"
                  autoComplete="given-name"
                  value={formData.firstName}
                  onChange={handleChange}
                />
              </Grid>
              <Grid item xs={12} sm={6}>
                <TextField
                  margin="normal"
                  fullWidth
                  id="lastName"
                  label="Last Name"
                  name="lastName"
                  autoComplete="family-name"
                  value={formData.lastName}
                  onChange={handleChange}
                />
              </Grid>
            </Grid>
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type="password"
              id="password"
              autoComplete="new-password"
              value={formData.password}
              onChange={handleChange}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Confirm Password"
              type="password"
              id="confirmPassword"
              value={formData.confirmPassword}
              onChange={handleChange}
            />
            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{ mt: 3, mb: 2 }}
              disabled={loading}
            >
              {loading ? 'Signing Up...' : 'Sign Up'}
            </Button>
            <Box sx={{ textAlign: 'center' }}>
              <Link component={RouterLink} to="/login" variant="body2">
                {'Already have an account? Sign In'}
              </Link>
            </Box>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
};

export default Register;
"""

# src/components/Dashboard/Dashboard.js
"""
import React, { useState, useEffect } from 'react';
import { Box, CssBaseline, Drawer, Toolbar } from '@mui/material';
import { useNavigate, Routes, Route } from 'react-router-dom';
import { isAuthenticated } from '../../services/auth';
import Header from '../Common/Header';
import Sidebar from './Sidebar';
import EmailList from './EmailList';
import EmailView from './EmailView';
import ThreadView from './ThreadView';
import AccountList from '../EmailAccounts/AccountList';
import AccountForm from '../EmailAccounts/AccountForm';
import UserProfile from '../User/UserProfile';

const drawerWidth = 240;

const Dashboard = () => {
  const navigate = useNavigate();
  const [open, setOpen] = useState(true);
  const [mobileOpen, setMobileOpen] = useState(false);

  useEffect(() => {
    // Redirect to login if not authenticated
    if (!isAuthenticated()) {
      navigate('/login');
    }
  }, [navigate]);

  const toggleDrawer = () => {
    setOpen(!open);
  };

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  return (
    <Box sx={{ display: 'flex' }}>
      <CssBaseline />
      <Header toggleSidebar={handleDrawerToggle} />
      
      {/* Mobile drawer */}
      <Drawer
        variant="temporary"
        open={mobileOpen}
        onClose={handleDrawerToggle}
        ModalProps={{
          keepMounted: true, // Better open performance on mobile
        }}
        sx={{
          display: { xs: 'block', sm: 'none' },
          '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
        }}
      >
        <Sidebar />
      </Drawer>
      
      {/* Desktop drawer */}
      <Drawer
        variant="permanent"
        open={open}
        sx={{
          display: { xs: 'none', sm: 'block' },
          '& .MuiDrawer-paper': { 
            boxSizing: 'border-box', 
            width: drawerWidth,
            position: 'relative',
            height: '100vh'
          },
          width: drawerWidth,
          flexShrink: 0,
        }}
      >
        <Sidebar />
      </Drawer>
      
      {/* Main content */}
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          p: 3,
          width: { sm: `calc(100% - ${drawerWidth}px)` },
          mt: 8
        }}
      >
        <Routes>
          <Route path="/" element={<EmailList />} />
          <Route path="/emails" element={<EmailList />} />
          <Route path="/emails/:emailId" element={<EmailView />} />
          <Route path="/threads" element={<EmailList showThreads={true} />} />
          <Route path="/threads/:threadId" element={<ThreadView />} />
          <Route path="/accounts" element={<AccountList />} />
          <Route path="/accounts/new" element={<AccountForm />} />
          <Route path="/accounts/:accountId" element={<AccountForm />} />
          <Route path="/profile" element={<UserProfile />} />
        </Routes>
      </Box>
    </Box>
  );
};

export default Dashboard;
"""

# src/components/Dashboard/Sidebar.js
"""
import React, { useState, useEffect } from 'react';
import {
  Box,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Divider,
  Toolbar,
  Typography,
  Collapse,
  Button,
} from '@mui/material';
import {
  Inbox as InboxIcon,
  Mail as MailIcon,
  Forum as ForumIcon,
  AccountCircle as AccountIcon,
  ExpandLess,
  ExpandMore,
  Refresh as RefreshIcon,
  Add as AddIcon,
} from '@mui/icons-material';
import { useNavigate, useLocation } from 'react-router-dom';
import { getEmailAccounts, syncEmailAccount } from '../../services/api';

const Sidebar = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const [accounts, setAccounts] = useState([]);
  const [accountsOpen, setAccountsOpen] = useState(true);
  const [loading, setLoading] = useState(false);
  const [syncingAccount, setSyncingAccount] = useState(null);

  useEffect(() => {
    fetchAccounts();
  }, []);

  const fetchAccounts = async () => {
    try {
      setLoading(true);
      const response = await getEmailAccounts();
      setAccounts(response.data.accounts);
    } catch (error) {
      console.error('Error fetching accounts:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSyncAccount = async (accountId, e) => {
    e.stopPropagation();
    try {
      setSyncingAccount(accountId);
      await syncEmailAccount(accountId);
      // Optionally refresh emails after sync
    } catch (error) {
      console.error('Error syncing account:', error);
    } finally {
      setSyncingAccount(null);
    }
  };

  const handleAccountsToggle = () => {
    setAccountsOpen(!accountsOpen);
  };

  const isActive = (path) => {
    return location.pathname === path;
  };

  return (
    <>
      <Toolbar>
        <Typography variant="h6" noWrap component="div">
          Email Organizer
        </Typography>
      </Toolbar>
      <Divider />
      <List>
        <ListItem disablePadding>
          <ListItemButton
            selected={isActive('/emails') || isActive('/')}
            onClick={() => navigate('/emails')}
          >
            <ListItemIcon>
              <InboxIcon />
            </ListItemIcon>
            <ListItemText primary="All Emails" />
          </ListItemButton>
        </ListItem>
        <ListItem disablePadding>
          <ListItemButton
            selected={isActive('/threads')}
            onClick={() => navigate('/threads')}
          >
            <ListItemIcon>
              <ForumIcon />
            </ListItemIcon>
            <ListItemText primary="Threads" />
          </ListItemButton>
        </ListItem>
      </List>
      <Divider />
      <List>
        <ListItem disablePadding>
          <ListItemButton onClick={handleAccountsToggle}>
            <ListItemIcon>
              <MailIcon />
            </ListItemIcon>
            <ListItemText primary="Email Accounts" />
            {accountsOpen ? <ExpandLess /> : <ExpandMore />}
          </ListItemButton>
        </ListItem>
        <Collapse in={accountsOpen} timeout="auto" unmountOnExit>
          <List component="div" disablePadding>
            {accounts.map((account) => (
              <ListItem
                key={account.id}
                disablePadding
                secondaryAction={
                  <Button
                    size="small"
                    onClick={(e) => handleSyncAccount(account.id, e)}
                    disabled={syncingAccount === account.id}
                  >
                    <RefreshIcon fontSize="small" />
                  </Button>
                }
              >
                <ListItemButton
                  sx={{ pl: 4 }}
                  onClick={() => navigate(`/emails?account_id=${account.id}`)}
                  selected={
                    location.pathname === '/emails' &&
                    location.search === `?account_id=${account.id}`
                  }
                >
                  <ListItemText
                    primary={account.name}
                    secondary={account.email}
                  />
                </ListItemButton>
              </ListItem>
            ))}
            <ListItem disablePadding>
              <ListItemButton
                sx={{ pl: 4 }}
                onClick={() => navigate('/accounts/new')}
              >
                <ListItemIcon>
                  <AddIcon />
                </ListItemIcon>
                <ListItemText primary="Add Account" />
              </ListItemButton>
            </ListItem>
          </List>
        </Collapse>
        <ListItem disablePadding>
          <ListItemButton
            selected={isActive('/accounts')}
            onClick={() => navigate('/accounts')}
          >
            <ListItemIcon>
              <MailIcon />
            </ListItemIcon>
            <ListItemText primary="Manage Accounts" />
          </ListItemButton>
        </ListItem>
        <ListItem disablePadding>
          <ListItemButton
            selected={isActive('/profile')}
            onClick={() => navigate('/profile')}
          >
            <ListItemIcon>
              <AccountIcon />
            </ListItemIcon>
            <ListItemText primary="Profile" />
          </ListItemButton>
        </ListItem>
      </List>
    </>
  );
};

export default Sidebar;
"""

# src/components/Dashboard/EmailList.js
"""
import React, { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  Typography,
  Chip,
  IconButton,
  TextField,
  InputAdornment,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
} from '@mui/material';
import { useNavigate, useLocation } from 'react-router-dom';
import {
  Search as SearchIcon,
  Attachment as AttachmentIcon,
} from '@mui/icons-material';
import { getEmails, getThreads } from '../../services/api';
import { formatDate, getRelativeTime } from '../../utils/dateUtils';
import { truncateText, formatEmailAddresses } from '../../utils/formatUtils';
import Loading from '../Common/Loading';
import ErrorMessage from '../Common/ErrorMessage';

const EmailList = ({ showThreads = false }) => {
  const navigate = useNavigate();
  const location = useLocation();
  const queryParams = new URLSearchParams(location.search);
  
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(25);
  const [filters, setFilters] = useState({
    account_id: queryParams.get('account_id') || '',
    from: '',
    to: '',
    subject: '',
    start_date: '',
    end_date: '',
    has_attachments: '',
  });
  const [searchTerm, setSearchTerm] = useState('');

  useEffect(() => {
    fetchItems();
  }, [location.search, showThreads]);

  const fetchItems = async () => {
    try {
      setLoading(true);
      setError('');
      
      // Build filters from URL query params
      const queryParams = new URLSearchParams(location.search);
      const apiFilters = {};
      
      for (const [key, value] of queryParams.entries()) {
        apiFilters[key] = value;
      }
      
      // Update filters state
      setFilters((prev) => ({
        ...prev,
        ...apiFilters,
      }));
      
      // Fetch data based on showThreads prop
      const response = showThreads
        ? await getThreads(apiFilters)
        : await getEmails(apiFilters);
      
      setItems(showThreads ? response.data.threads : response.data.emails);
    } catch (err) {
      console.error('Error fetching data:', err);
      setError(
        err.response?.data?.message || 'An error occurred while fetching data'
      );
    } finally {
      setLoading(false);
    }
  };

  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const handleItemClick = (id) => {
    if (showThreads) {
      navigate(`/threads/${id}`);
    } else {
      navigate(`/emails/${id}`);
    }
  };

  const handleFilterChange = (e) => {
    const { name, value } = e.target;
    setFilters((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const applyFilters = () => {
    // Build query string from filters
    const queryParams = new URLSearchParams();
    
    for (const [key, value] of Object.entries(filters)) {
      if (value) {
        queryParams.set(key, value);
      }
    }
    
    // Navigate to same route with updated query params
    navigate({
      pathname: location.pathname,
      search: queryParams.toString(),
    });
  };

  const handleSearch = (e) => {
    e.preventDefault();
    setFilters((prev) => ({
      ...prev,
      subject: searchTerm,
    }));
    applyFilters();
  };

  if (loading) {
    return <Loading message="Loading emails..." />;
  }

  return (
    <Box>
      <Typography variant="h5" gutterBottom>
        {showThreads ? 'Email Threads' : 'All Emails'}
      </Typography>
      
      <ErrorMessage message={error} onClose={() => setError('')} />
      
      {/* Search and filters */}
      <Box
        component="form"
        onSubmit={handleSearch}
        sx={{ mb: 3, display: 'flex', gap: 2, flexWrap: 'wrap' }}
      >
        <TextField
          label="Search"
          variant="outlined"
          size="small"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          InputProps={{
            endAdornment: (
              <InputAdornment position="end">
                <IconButton type="submit" edge="end">
                  <SearchIcon />
                </IconButton>
              </InputAdornment>
            ),
          }}
          sx={{ flexGrow: 1, minWidth: '200px' }}
        />
        
        <FormControl size="small" sx={{ minWidth: '150px' }}>
          <InputLabel>Has Attachments</InputLabel>
          <Select
            name="has_attachments"
            value={filters.has_attachments}
            label="Has Attachments"
            onChange={handleFilterChange}
          >
            <MenuItem value="">All</MenuItem>
            <MenuItem value="true">Yes</MenuItem>
            <MenuItem value="false">No</MenuItem>
          </Select>
        </FormControl>
      </Box>
      
      {/* Email/Thread list */}
      <TableContainer component={Paper}>
        <Table sx={{ minWidth: 650 }} aria-label="email list">
          <TableHead>
            <TableRow>
              <TableCell>{showThreads ? 'Subject' : 'From'}</TableCell>
              {!showThreads && <TableCell>Subject</TableCell>}
              <TableCell>Date</TableCell>
              {showThreads && <TableCell>Emails</TableCell>}
            </TableRow>
          </TableHead>
          <TableBody>
            {items.length === 0 ? (
              <TableRow>
                <TableCell colSpan={showThreads ? 3 : 3} align="center">
                  No {showThreads ? 'threads' : 'emails'} found
                </TableCell>
              </TableRow>
            ) : (
              items
                .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)
                .map((item) => (
                  <TableRow
                    key={item.id}
                    hover
                    onClick={() => handleItemClick(item.id)}
                    sx={{ cursor: 'pointer' }}
                  >
                    <TableCell>
                      {showThreads
                        ? truncateText(item.subject, 50)
                        : item.from_address}
                    </TableCell>
                    {!showThreads && (
                      <TableCell>
                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                          {truncateText(item.subject, 50)}
                          {item.has_attachments && (
                            <AttachmentIcon
                              fontSize="small"
                              sx={{ ml: 1, opacity: 0.6 }}
                            />
                          )}
                        </Box>
                      </TableCell>
                    )}
                    <TableCell>
                      {showThreads
                        ? formatDate(item.last_date)
                        : getRelativeTime(item.date_sent)}
                    </TableCell>
                    {showThreads && (
                      <TableCell>
                        <Chip
                          label={item.email_count}
                          size="small"
                          color="primary"
                        />
                      </TableCell>
                    )}
                  </TableRow>
                ))
            )}
          </TableBody>
        </Table>
        <TablePagination
          rowsPerPageOptions={[10, 25, 50, 100]}
          component="div"
          count={items.length}
          rowsPerPage={rowsPerPage}
          page={page}
          onPageChange={handleChangePage}
          onRowsPerPageChange={handleChangeRowsPerPage}
        />
      </TableContainer>
    </Box>
  );
};

export default EmailList;
"""

# src/components/Dashboard/EmailView.js
"""
import React, { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Typography,
  Divider,
  Chip,
  Button,
  IconButton,
  Tooltip,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
} from '@mui/material';
import {
  Reply as ReplyIcon,
  ReplyAll as ReplyAllIcon,
  Forward as ForwardIcon,
  AttachFile as AttachmentIcon,
  Download as DownloadIcon,
  Forum as ThreadIcon,
} from '@mui/icons-material';
import { useParams, useNavigate } from 'react-router-dom';
import { getEmail, getEmailAttachment } from '../../services/api';
import { formatDate } from '../../utils/dateUtils';
import { formatFileSize } from '../../utils/formatUtils';
import Loading from '../Common/Loading';
import ErrorMessage from '../Common/ErrorMessage';

const EmailView = () => {
  const { emailId } = useParams();
  const navigate = useNavigate();
  const [email, setEmail] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    fetchEmail();
  }, [emailId]);

  const fetchEmail = async () => {
    try {
      setLoading(true);
      setError('');
      const response = await getEmail(emailId);
      setEmail(response.data);
    } catch (err) {
      console.error('Error fetching email:', err);
      setError(
        err.response?.data?.message || 'An error occurred while fetching the email'
      );
    } finally {
      setLoading(false);
    }
  };

  const handleDownloadAttachment = async (attachmentId, filename) => {
    try {
      const response = await getEmailAttachment(emailId, attachmentId);
      
      // Create a download link
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', filename);
      document.body.appendChild(link);
      link.click();
      link.remove();
    } catch (err) {
      console.error('Error downloading attachment:', err);
      setError(
        err.response?.data?.message || 'An error occurred while downloading the attachment'
      );
    }
  };

  const handleViewThread = () => {
    if (email && email.thread_id) {
      navigate(`/threads/${email.thread_id}`);
    }
  };

  if (loading) {
    return <Loading message="Loading email..." />;
  }

  if (!email) {
    return (
      <Box>
        <ErrorMessage
          message={error || 'Email not found'}
          onClose={() => setError('')}
        />
      </Box>
    );
  }

  return (
    <Box>
      <Paper sx={{ p: 3, mb: 3 }}>
        {/* Email header */}
        <Box sx={{ mb: 2 }}>
          <Typography variant="h5" gutterBottom>
            {email.subject}
          </Typography>
          
          <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
            <Typography variant="body1">
              <strong>From:</strong> {email.from_address}
            </Typography>
            <Typography variant="body2" color="text.secondary">
              {formatDate(email.date_sent)}
            </Typography>
          </Box>
          
          <Typography variant="body1" gutterBottom>
            <strong>To:</strong> {email.to_addresses.join(', ')}
          </Typography>
          
          {email.thread_id && (
            <Button
              startIcon={<ThreadIcon />}
              onClick={handleViewThread}
              size="small"
              sx={{ mt: 1 }}
            >
              View Thread
            </Button>
          )}
        </Box>
        
        <Divider sx={{ my: 2 }} />
        
        {/* Email actions */}
        <Box sx={{ display: 'flex', gap: 1, mb: 2 }}>
          <Tooltip title="Reply">
            <IconButton>
              <ReplyIcon />
            </IconButton>
          </Tooltip>
          <Tooltip title="Reply All">
            <IconButton>
              <ReplyAllIcon />
            </IconButton>
          </Tooltip>
          <Tooltip title="Forward">
            <IconButton>
              <ForwardIcon />
            </IconButton>
          </Tooltip>
        </Box>
        
        {/* Attachments */}
        {email.attachments && email.attachments.length > 0 && (
          <Box sx={{ mb: 3 }}>
            <Typography variant="subtitle1" gutterBottom>
              Attachments ({email.attachments.length})
            </Typography>
            <List dense>
              {email.attachments.map((attachment) => (
                <ListItem
                  key={attachment.id}
                  secondaryAction={
                    <IconButton
                      edge="end"
                      onClick={() =>
                        handleDownloadAttachment(
                          attachment.id,
                          attachment.filename
                        )
                      }
                    >
                      <DownloadIcon />
                    </IconButton>
                  }
                >
                  <ListItemIcon>
                    <AttachmentIcon />
                  </ListItemIcon>
                  <ListItemText
                    primary={attachment.filename}
                    secondary={formatFileSize(attachment.size)}
                  />
                </ListItem>
              ))}
            </List>
          </Box>
        )}
        
        <Divider sx={{ my: 2 }} />
        
        {/* Email content */}
        <Box sx={{ mt: 2 }}>
          {email.html ? (
            <Box
              dangerouslySetInnerHTML={{ __html: email.html }}
              sx={{
                '& img': {
                  maxWidth: '100%',
                  height: 'auto',
                },
              }}
            />
          ) : (
            <Typography
              variant="body1"
              component="div"
              sx={{ whiteSpace: 'pre-wrap' }}
            >
              {email.body}
            </Typography>
          )}
        </Box>
        
        {/* Disclaimers */}
        {email.disclaimers && email.disclaimers.length > 0 && (
          <Box sx={{ mt: 4, pt: 2, borderTop: '1px solid #eee' }}>
            {email.disclaimers.map((disclaimer, index) => (
              <Typography
                key={index}
                variant="caption"
                color="text.secondary"
                component="div"
                sx={{ mt: 1, fontStyle: 'italic' }}
              >
                {disclaimer.text}
              </Typography>
            ))}
          </Box>
        )}
      </Paper>
    </Box>
  );
};

export default EmailView;
"""

# src/components/Dashboard/ThreadView.js
"""
import React, { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Typography,
  Divider,
  List,
  ListItem,
  ListItemText,
  ListItemAvatar,
  Avatar,
  Collapse,
  IconButton,
  Chip,
  Button,
} from '@mui/material';
import {
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
  AttachFile as AttachmentIcon,
  Reply as ReplyIcon,
  ReplyAll as ReplyAllIcon,
  Forward as ForwardIcon,
} from '@mui/icons-material';
import { useParams, useNavigate } from 'react-router-dom';
import { getThread, getEmail } from '../../services/api';
import { formatDate } from '../../utils/dateUtils';
import { extractName } from '../../utils/formatUtils';
import Loading from '../Common/Loading';
import ErrorMessage from '../Common/ErrorMessage';

const ThreadView = () => {
  const { threadId } = useParams();
  const navigate = useNavigate();
  const [thread, setThread] = useState(null);
  const [expandedEmails, setExpandedEmails] = useState({});
  const [emailContents, setEmailContents] = useState({});
  const [loading, setLoading] = useState(true);
  const [loadingEmail, setLoadingEmail] = useState({});
  const [error, setError] = useState('');

  useEffect(() => {
    fetchThread();
  }, [threadId]);

  const fetchThread = async () => {
    try {
      setLoading(true);
      setError('');
      const response = await getThread(threadId);
      
      // Sort emails by date
      const sortedEmails = [...response.data.emails].sort((a, b) => {
        return new Date(a.date_sent) - new Date(b.date_sent);
      });
      
      setThread({
        ...response.data,
        emails: sortedEmails,
      });
      
      // Expand the most recent email by default
      if (sortedEmails.length > 0) {
        const latestEmailId = sortedEmails[sortedEmails.length - 1].id;
        setExpandedEmails({ [latestEmailId]: true });
        fetchEmailContent(latestEmailId);
      }
    } catch (err) {
      console.error('Error fetching thread:', err);
      setError(
        err.response?.data?.message || 'An error occurred while fetching the thread'
      );
    } finally {
      setLoading(false);
    }
  };

  const fetchEmailContent = async (emailId) => {
    if (emailContents[emailId]) return;
    
    try {
      setLoadingEmail((prev) => ({ ...prev, [emailId]: true }));
      const response = await getEmail(emailId);
      setEmailContents((prev) => ({
        ...prev,
        [emailId]: response.data,
      }));
    } catch (err) {
      console.error(`Error fetching email ${emailId}:`, err);
    } finally {
      setLoadingEmail((prev) => ({ ...prev, [emailId]: false }));
    }
  };

  const toggleEmailExpand = (emailId) => {
    setExpandedEmails((prev) => ({
      ...prev,
      [emailId]: !prev[emailId],
    }));
    
    if (!expandedEmails[emailId] && !emailContents[emailId]) {
      fetchEmailContent(emailId);
    }
  };

  const handleViewEmail = (emailId) => {
    navigate(`/emails/${emailId}`);
  };

  if (loading) {
    return <Loading message="Loading thread..." />;
  }

  if (!thread) {
    return (
      <Box>
        <ErrorMessage
          message={error || 'Thread not found'}
          onClose={() => setError('')}
        />
      </Box>
    );
  }

  return (
    <Box>
      <Paper sx={{ p: 3, mb: 3 }}>
        {/* Thread header */}
        <Box sx={{ mb: 3 }}>
          <Typography variant="h5" gutterBottom>
            {thread.subject}
          </Typography>
          <Typography variant="body2" color="text.secondary">
            {thread.emails.length} messages from{' '}
            {formatDate(thread.date_started)} to {formatDate(thread.last_date)}
          </Typography>
        </Box>
        
        <Divider sx={{ my: 2 }} />
        
        {/* Thread emails */}
        <List sx={{ width: '100%' }}>
          {thread.emails.map((email) => (
            <React.Fragment key={email.id}>
              <ListItem
                alignItems="flex-start"
                button
                onClick={() => toggleEmailExpand(email.id)}
                sx={{
                  backgroundColor: expandedEmails[email.id]
                    ? 'rgba(0, 0, 0, 0.04)'
                    : 'transparent',
                }}
              >
                <ListItemAvatar>
                  <Avatar alt={extractName(email.from_address)}>
                    {extractName(email.from_address).charAt(0).toUpperCase()}
                  </Avatar>
                </ListItemAvatar>
                <ListItemText
                  primary={
                    <Box
                      sx={{
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                      }}
                    >
                      <Typography variant="subtitle1">
                        {email.from_address}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        {formatDate(email.date_sent)}
                      </Typography>
                    </Box>
                  }
                  secondary={
                    <Box>
                      <Typography
                        variant="body2"
                        color="text.primary"
                        component="span"
                      >
                        {email.subject}
                      </Typography>
                      {email.has_attachments && (
                        <AttachmentIcon
                          fontSize="small"
                          sx={{ ml: 1, verticalAlign: 'middle' }}
                        />
                      )}
                    </Box>
                  }
                />
                {expandedEmails[email.id] ? (
                  <ExpandLessIcon />
                ) : (
                  <ExpandMoreIcon />
                )}
              </ListItem>
              
              <Collapse
                in={expandedEmails[email.id]}
                timeout="auto"
                unmountOnExit
              >
                <Box sx={{ p: 3, pl: 9 }}>
                  {loadingEmail[email.id] ? (
                    <Loading message="Loading email content..." />
                  ) : emailContents[email.id] ? (
                    <>
                      {/* Email actions */}
                      <Box sx={{ display: 'flex', gap: 1, mb: 2 }}>
                        <Button
                          size="small"
                          startIcon={<ReplyIcon />}
                          variant="outlined"
                        >
                          Reply
                        </Button>
                        <Button
                          size="small"
                          startIcon={<ReplyAllIcon />}
                          variant="outlined"
                        >
                          Reply All
                        </Button>
                        <Button
                          size="small"
                          startIcon={<ForwardIcon />}
                          variant="outlined"
                        >
                          Forward
                        </Button>
                        <Button
                          size="small"
                          variant="text"
                          onClick={() => handleViewEmail(email.id)}
                        >
                          View Full Email
                        </Button>
                      </Box>
                      
                      {/* Email content */}
                      {emailContents[email.id].html ? (
                        <Box
                          dangerouslySetInnerHTML={{
                            __html: emailContents[email.id].html,
                          }}
                          sx={{
                            '& img': {
                              maxWidth: '100%',
                              height: 'auto',
                            },
                          }}
                        />
                      ) : (
                        <Typography
                          variant="body1"
                          component="div"
                          sx={{ whiteSpace: 'pre-wrap' }}
                        >
                          {emailContents[email.id].body}
                        </Typography>
                      )}
                      
                      {/* Attachments */}
                      {emailContents[email.id].attachments &&
                        emailContents[email.id].attachments.length > 0 && (
                          <Box sx={{ mt: 2 }}>
                            <Typography variant="subtitle2" gutterBottom>
                              Attachments:
                            </Typography>
                            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                              {emailContents[email.id].attachments.map(
                                (attachment) => (
                                  <Chip
                                    key={attachment.id}
                                    icon={<AttachmentIcon />}
                                    label={attachment.filename}
                                    variant="outlined"
                                    onClick={() => handleViewEmail(email.id)}
                                  />
                                )
                              )}
                            </Box>
                          </Box>
                        )}
                    </>
                  ) : (
                    <Typography color="text.secondary">
                      Click to load email content
                    </Typography>
                  )}
                </Box>
              </Collapse>
              <Divider component="li" />
            </React.Fragment>
          ))}
        </List>
      </Paper>
    </Box>
  );
};

export default ThreadView;
"""
